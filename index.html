<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snapshot ‚Äî Integrated Analysis</title>
    <link href="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.css" rel="stylesheet" />
    <link rel="icon" type="image/png" href="https://images.squarespace-cdn.com/content/6087714b06d1991ac79e63c7/38666ce2-a0f9-4bcb-a352-98044e680157/LANDVOLT.png?format=100w&content-type=image%2Fpng">
    <script src="https://unpkg.com/maplibre-gl@4.1.2/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-primary: #0a0d14;
            --bg-secondary: #111827;
            --bg-tertiary: #1f2937;
            --accent-cyan: #06b6d4;
            --accent-emerald: #10b981;
            --accent-amber: #f59e0b;
            --accent-violet: #8b5cf6;
            --accent-rose: #f43f5e;
            --accent-orange: #f97316;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border-color: rgba(75, 85, 99, 0.5);
            --glass-bg: rgba(17, 24, 39, 0.95);
            --glass-border: rgba(75, 85, 99, 0.4);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Space Grotesk', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            overflow-y: auto;
            display: flex;
            min-height: 100vh;
        }

        /* SIDEBAR */
        .sidebar {
            width: 340px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 20;
            position: fixed;
            top: 0; bottom: 0; left: 0;
        }
        .sidebar-header {
            padding: 18px 20px;
            border-bottom: 1px solid var(--border-color);
            background: linear-gradient(180deg, rgba(6, 182, 212, 0.08) 0%, transparent 100%);
            flex-shrink: 0;
        }
        .logo { display: flex; align-items: center; gap: 10px; margin-bottom: 2px; }
        .logo-icon {
            width: 32px; height: 32px;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-emerald));
            border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px;
        }
        .logo h1 {
            font-size: 20px; font-weight: 700; letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-cyan) 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        .tagline { font-size: 11px; color: var(--text-secondary); margin-left: 42px; }

        .sidebar-content { flex: 1; overflow-y: auto; }
        .sidebar-content::-webkit-scrollbar { width: 4px; }
        .sidebar-content::-webkit-scrollbar-thumb { background: var(--bg-tertiary); }

        .control-section { padding: 16px 20px; border-bottom: 1px solid var(--border-color); }
        .control-section .search-hint {
            font-size: 8px;
            line-height: 1.2;
        }
        .section-label {
            display: flex; align-items: center; gap: 6px;
            font-size: 10px; font-weight: 600; color: var(--accent-cyan);
            text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 10px;
        }

        .search-container { display: flex; gap: 8px; }
        .search-input {
            flex: 1; background: var(--bg-tertiary);
            border: 1px solid var(--glass-border); border-radius: 8px;
            padding: 10px 12px; color: var(--text-primary);
            font-size: 13px; font-family: inherit; outline: none; transition: all 0.2s;
        }
        .search-input:focus { border-color: var(--accent-cyan); box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.15); }
        .search-btn {
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-emerald));
            border: none; border-radius: 8px; padding: 10px 16px;
            color: var(--bg-primary); font-weight: 600; font-size: 12px;
            cursor: pointer; text-transform: uppercase; letter-spacing: 0.05em;
        }
        .search-btn:hover { filter: brightness(1.1); }
        .search-hint { font-size: 10px; color: var(--text-muted); margin-top: 6px; font-family: 'IBM Plex Mono', monospace; }
        .search-hint code { background: rgba(6, 182, 212, 0.15); padding: 2px 5px; border-radius: 4px; color: var(--accent-cyan); }

        .slider-group { margin-bottom: 16px; }
        .slider-group label {
            display: flex; justify-content: space-between;
            font-size: 11px; color: var(--text-secondary); margin-bottom: 6px;
        }
        .slider-group label span.val { color: var(--text-primary); font-family: 'IBM Plex Mono', monospace; }
        .buffer-slider {
            width: 100%; -webkit-appearance: none; appearance: none;
            height: 4px; background: var(--bg-tertiary); border-radius: 999px; outline: none;
        }
        .buffer-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px;
            border-radius: 999px; cursor: pointer; border: 2px solid var(--bg-primary);
        }
        #slider-infra::-webkit-slider-thumb { background: var(--accent-cyan); }
        #slider-env::-webkit-slider-thumb { background: var(--accent-emerald); }

        .shape-toggle { display: flex; gap: 12px; margin-top: 12px; }
        .shape-toggle label { display: flex; align-items: center; gap: 5px; font-size: 11px; color: var(--text-secondary); cursor: pointer; }
        .shape-toggle input { accent-color: var(--accent-cyan); }

        .layer-group-title { font-size: 9px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.1em; margin: 12px 0 6px 0; }
        .layer-toggle { display: flex; align-items: center; padding: 6px 0; cursor: pointer; }
        .layer-checkbox {
            width: 14px; height: 14px; border-radius: 3px; margin-right: 8px;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid; font-size: 9px;
        }
        .layer-checkbox.checked { background: currentColor; }
        .layer-checkbox.checked::after { content: '‚úì'; color: var(--bg-primary); font-weight: 800; }
        
        .c-infra { color: var(--accent-cyan); border-color: var(--accent-cyan); }
        .c-env { color: var(--accent-emerald); border-color: var(--accent-emerald); }
        .c-sub { color: var(--accent-rose); border-color: var(--accent-rose); }
        .c-pipe { color: var(--accent-orange); border-color: var(--accent-orange); }
        .c-flood { color: var(--accent-amber); border-color: var(--accent-amber); }
        .c-prot { color: var(--accent-violet); border-color: var(--accent-violet); }
        .c-wet { color: #3b82f6; border-color: #3b82f6; }
        .c-crithab { color: #dc2626; border-color: #dc2626; }
        .c-crithab-prop { color: #f472b6; border-color: #f472b6; }
        .c-solar { color: #fbbf24; border-color: #fbbf24; }

        /* Fatal Flaw Styles */
        .fatal-flaw-banner {
            background: linear-gradient(135deg, #991b1b 0%, #dc2626 100%);
            border: 2px solid #f87171;
            border-radius: 8px;
            padding: 12px 16px;
            margin: 10px 0;
            display: none;
        }
        .fatal-flaw-banner.active { display: block; }
        .fatal-flaw-title {
            font-size: 12px;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .fatal-flaw-list {
            font-size: 11px;
            color: #fecaca;
            line-height: 1.5;
        }
        .fatal-flaw-item {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .fatal-flaw-item:last-child { border-bottom: none; }
        
        .warning-banner {
            background: linear-gradient(135deg, #92400e 0%, #f59e0b 100%);
            border: 2px solid #fbbf24;
            border-radius: 8px;
            padding: 12px 16px;
            margin: 10px 0;
            display: none;
        }
        .warning-banner.active { display: block; }
        .warning-title {
            font-size: 12px;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .warning-list {
            font-size: 11px;
            color: #fef3c7;
            line-height: 1.5;
        }

        .site-score {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            text-align: center;
        }
        .site-score-label {
            font-size: 10px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 4px;
        }
        .site-score-value {
            font-size: 28px;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
        }
        .site-score-rating {
            font-size: 11px;
            font-weight: 600;
            margin-top: 4px;
        }
        .score-fatal { color: #ef4444; }
        .score-poor { color: #f97316; }
        .score-fair { color: #eab308; }
        .score-good { color: #22c55e; }
        .score-excellent { color: #06b6d4; }

        .layer-label { font-size: 12px; color: var(--text-secondary); }
        
        /* MAIN CONTENT */
        .main-content {
            margin-left: 340px;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .map-wrapper {
            height: 65vh; 
            width: 100%;
            position: relative;
            background: #000;
        }
        #map { position: absolute; inset: 0; }

        .legend-panel {
            position: absolute; bottom: 20px; right: 20px;
            background: var(--glass-bg); border: 1px solid var(--glass-border);
            border-radius: 8px; padding: 12px; z-index: 10;
            font-size: 10px; max-height: 300px; overflow-y: auto;
        }
        .legend-title { font-weight: 700; text-transform: uppercase; margin-bottom: 8px; color: var(--text-primary); }
        .legend-item { display: flex; align-items: center; margin-bottom: 4px; color: var(--text-secondary); }
        .l-box { width: 10px; height: 10px; border-radius: 2px; margin-right: 6px; }
        .l-line { width: 14px; height: 3px; border-radius: 2px; margin-right: 6px; }
        .l-dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; }

        /* RESULTS */
        .results-wrapper {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            display: flex; 
            flex-direction: column;
            min-height: 400px;
            flex: 1;
        }
        
        .results-placeholder {
            display: flex; align-items: center; justify-content: center;
            height: 100%; color: var(--text-muted); font-size: 13px;
            padding: 40px; text-align: center;
        }

        .results-container {
            display: none;
            flex-direction: column;
            height: 100%;
        }
        .results-container.active { display: flex; }

        .results-header {
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center;
            background: var(--bg-tertiary);
        }
        .results-title h2 { font-size: 14px; font-weight: 600; color: var(--text-primary); }
        .results-meta { font-size: 11px; color: var(--text-muted); font-family: 'IBM Plex Mono', monospace; margin-left: 10px; }

        .stats-row {
            display: flex; gap: 10px; padding: 12px 20px;
            overflow-x: auto; background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }
        .stat-card {
            background: var(--bg-tertiary); border: 1px solid var(--glass-border);
            border-radius: 6px; padding: 8px 12px; min-width: 100px;
            flex-shrink: 0;
        }
        .stat-label { font-size: 9px; text-transform: uppercase; color: var(--text-muted); margin-bottom: 4px; letter-spacing: 0.05em; }
        .stat-value { font-size: 13px; font-weight: 700; color: var(--text-primary); font-family: 'IBM Plex Mono', monospace; }
        .stat-subtext { font-size: 9px; color: var(--text-secondary); margin-top: 2px; }

        .tabs-row {
            display: flex; border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        .tab-btn {
            padding: 10px 20px; background: none; border: none;
            color: var(--text-muted); font-size: 12px; font-weight: 600;
            cursor: pointer; border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { color: var(--text-primary); }
        .tab-btn.active { color: var(--accent-cyan); border-bottom-color: var(--accent-cyan); background: rgba(6,182,212,0.05); }

        .results-body {
            flex: 1; display: flex; min-height: 400px;
        }
        .results-list {
            flex: 1; padding: 16px; overflow-y: auto;
        }

        .r-item {
            display: inline-block; width: 300px;
            background: var(--bg-tertiary); border: 1px solid var(--glass-border);
            border-radius: 6px; padding: 12px; margin: 0 10px 10px 0;
            vertical-align: top;
        }
        .r-head { font-size: 12px; font-weight: 700; margin-bottom: 8px; color: var(--text-primary); }
        .r-row { display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 2px; }
        .r-row:last-child { border: none; }
        .r-lbl { color: var(--text-muted); }
        .r-val { color: var(--text-secondary); text-align: right; font-weight: 500; }

        .export-sidebar {
            width: 220px; border-left: 1px solid var(--border-color);
            padding: 16px; background: var(--bg-secondary);
            display: flex; flex-direction: column; gap: 8px;
        }
        .export-header { font-size: 10px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px; }
        .btn-export {
            padding: 10px; border-radius: 6px; border: 1px solid var(--glass-border);
            background: var(--bg-tertiary); color: var(--text-primary);
            font-size: 11px; cursor: pointer; text-align: left;
            display: flex; align-items: center; gap: 8px;
        }
        .btn-export:hover { border-color: var(--accent-cyan); color: var(--accent-cyan); }
        .btn-export.primary { background: linear-gradient(135deg, var(--accent-cyan), var(--accent-emerald)); color: #0a0d14; border: none; font-weight: 700; }
        .btn-export.primary:hover { filter: brightness(1.1); }

        .loading-overlay {
            position: absolute; inset: 0; background: rgba(10, 13, 20, 0.8);
            backdrop-filter: blur(4px); z-index: 100;
            display: none; align-items: center; justify-content: center; flex-direction: column;
        }
        .loading-overlay.active { display: flex; }
        .spinner {
            width: 40px; height: 40px; border: 3px solid rgba(6,182,212,0.3);
            border-top-color: var(--accent-cyan); border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 10px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: var(--accent-emerald); color: #000;
            padding: 10px 20px; border-radius: 20px; font-weight: 600; font-size: 13px;
            opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 200;
        }
        .toast.show { opacity: 1; }
    </style>
</head>
<body>

    <div class="sidebar">
        <div class="sidebar-header">
            <div class="logo"><div class="logo-icon">üåç</div><h1>Snapshot</h1></div>
            <div class="tagline">Integrated Analysis Engine v2.0</div>
        </div>

        <div class="sidebar-content">
            <div class="control-section">
                <div class="section-label">üìç Location Analysis</div>
                <div class="search-container">
                    <input type="text" class="search-input" id="search-input" placeholder="Address, City, or Lat,Lng">
                    <button class="search-btn" id="search-btn">Analyze</button>
                </div>
                <div class="search-hint">e.g. <code>41.27953, -95.93125</code> or <code>2222 N 11th st, Omaha</code></div>
            </div>
            <div class="control-section">
                <div class="section-label">üìè Analysis Buffers</div>
                
                <div class="slider-group">
                    <label>
                        <span>‚ö° Infrastructure</span>
                        <span class="val" id="val-infra">2.0 mi</span>
                    </label>
                    <input type="range" class="buffer-slider" id="slider-infra" min="0.5" max="20" step="0.5" value="2.0">
                </div>

                <div class="slider-group">
                    <label>
                        <span>üåø Environmental</span>
                        <span class="val" id="val-env">0.25 mi</span>
                    </label>
                    <input type="range" class="buffer-slider" id="slider-env" min="0.1" max="2.0" step="0.05" value="0.25">
                </div>

                <div class="shape-toggle">
                    <label><input type="radio" name="buffer-shape" value="circle" checked> Circle</label>
                    <label><input type="radio" name="buffer-shape" value="square"> Square</label>
                </div>
            </div>

            <div class="control-section">
                <div class="section-label">üó∫Ô∏è Data Layers</div>

                <div class="layer-group-title">Basemap</div>
                <div class="layer-toggle" data-layer="basemap" data-style="carto-dark"><div class="layer-checkbox c-infra checked"></div><span class="layer-label">Dark Street Map</span></div>
                <div class="layer-toggle" data-layer="basemap" data-style="satellite"><div class="layer-checkbox c-infra"></div><span class="layer-label">Satellite Imagery</span></div>

                <div class="layer-group-title">Environmental</div>
                <div class="layer-toggle" data-layer="landuse"><div class="layer-checkbox c-env checked"></div><span class="layer-label">Land Use (NLCD)</span></div>
                <div class="layer-toggle" data-layer="wetlands"><div class="layer-checkbox c-wet checked"></div><span class="layer-label">Wetlands (NWI)</span></div>
                <div class="layer-toggle" data-layer="wetlands_mapright"><div class="layer-checkbox c-wet"></div><span class="layer-label">Wetlands (National)</span></div>
                <div class="layer-toggle" data-layer="floodzone"><div class="layer-checkbox c-flood checked"></div><span class="layer-label">Flood Zones (FEMA)</span></div>
                <div class="layer-toggle" data-layer="nflood_floodzones"><div class="layer-checkbox c-flood"></div><span class="layer-label">Flood Data (National)</span></div>
                <div class="layer-toggle" data-layer="nfhl_flood"><div class="layer-checkbox c-flood"></div><span class="layer-label">Flood Hazard (NFHL)</span></div>
                <div class="layer-toggle" data-layer="protected"><div class="layer-checkbox c-prot checked"></div><span class="layer-label">Protected Areas</span></div>
                <div class="layer-toggle" data-layer="crithab_final"><div class="layer-checkbox c-crithab checked"></div><span class="layer-label">Critical Habitat (Final)</span></div>
                <div class="layer-toggle" data-layer="crithab_proposed"><div class="layer-checkbox c-crithab-prop"></div><span class="layer-label">Critical Habitat (Proposed)</span></div>

                <div class="layer-group-title">Solar Resource</div>
                <div class="layer-toggle" data-layer="solar_ghi"><div class="layer-checkbox c-solar checked"></div><span class="layer-label">Solar Irradiance (GHI)</span></div>

                <div class="layer-group-title">Infrastructure</div>
                <div class="layer-toggle" data-layer="transmission"><div class="layer-checkbox c-infra checked"></div><span class="layer-label">Transmission Lines</span></div>
                <div class="layer-toggle" data-layer="substations"><div class="layer-checkbox c-sub checked"></div><span class="layer-label">Substations</span></div>
                <div class="layer-toggle" data-layer="pipelines"><div class="layer-checkbox c-pipe checked"></div><span class="layer-label">Gas Pipelines</span></div>
            </div>
        </div>
    </div>

    <div class="main-content">
        <div class="loading-overlay" id="loading">
            <div class="spinner"></div>
            <div style="color:white; font-size:14px; font-weight:600;">Processing Spatial Data...</div>
            <div style="color:#9ca3af; font-size:11px; margin-top:5px;">Querying federal databases</div>
        </div>

        <div class="map-wrapper">
            <div id="map"></div>
            <div class="legend-panel">
                <div class="legend-title">Legend</div>
                <div style="font-size:9px;color:#6b7280;margin-bottom:8px;text-transform:uppercase;">Transmission</div>
                <div class="legend-item"><div class="l-line" style="background:#6366f1"></div> &lt;100 kV</div>
                <div class="legend-item"><div class="l-line" style="background:#8b5cf6"></div> 100-161 kV</div>
                <div class="legend-item"><div class="l-line" style="background:#22d3ee"></div> 220-287 kV</div>
                <div class="legend-item"><div class="l-line" style="background:#4ade80"></div> 345 kV</div>
                <div class="legend-item"><div class="l-line" style="background:#facc15"></div> 500 kV</div>
                <div class="legend-item"><div class="l-line" style="background:#fb923c"></div> 735+ kV</div>
                <div class="legend-item"><div class="l-line" style="background:#f472b6"></div> DC</div>
                <div style="font-size:9px;color:#6b7280;margin:8px 0;text-transform:uppercase;">Infrastructure</div>
                <div class="legend-item"><div class="l-dot" style="background:#f43f5e"></div> Substations</div>
                <div class="legend-item"><div class="l-line" style="background:#f97316"></div> Gas Pipelines</div>
                <div style="font-size:9px;color:#6b7280;margin:8px 0;text-transform:uppercase;">Environmental</div>
                <div class="legend-item"><div class="l-box" style="background:#3b82f6"></div> Wetlands</div>
                <div class="legend-item"><div class="l-box" style="background:#f59e0b"></div> Flood Zones</div>
                <div class="legend-item"><div class="l-box" style="background:#8b5cf6"></div> Protected Areas</div>
                <div class="legend-item"><div class="l-box" style="background:#dc2626"></div> Critical Habitat (Final)</div>
                <div class="legend-item"><div class="l-box" style="background:#f472b6"></div> Critical Habitat (Proposed)</div>
            </div>
        </div>

        <div class="results-wrapper" id="results-panel">
            <div class="results-placeholder" id="res-placeholder">
                <div>
                    <div style="font-size:30px; margin-bottom:10px;">üì°</div>
                    Enter a location and click Analyze<br>to generate a report.
                </div>
            </div>

            <div class="results-container" id="res-container">
                <div class="results-header">
                    <div class="results-title">
                        <h2>Analysis Results</h2>
                        <span class="results-meta" id="res-meta">--</span>
                    </div>
                </div>

                <div class="stats-row">
                    <div class="stat-card" style="border-color: rgba(6,182,212,0.5);">
                        <div class="stat-label">Highest Voltage</div>
                        <div class="stat-value" id="stat-max-volt">--</div>
                        <div class="stat-subtext" id="stat-volt-dist"></div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(244,63,94,0.5);">
                        <div class="stat-label">Nearest Substation</div>
                        <div class="stat-value" id="stat-sub-dist">--</div>
                        <div class="stat-subtext" id="stat-sub-name">N/A</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(249,115,22,0.5);">
                        <div class="stat-label">Pipelines</div>
                        <div class="stat-value" id="stat-pipe-count">0</div>
                        <div class="stat-subtext">Segments</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(16,185,129,0.5);">
                        <div class="stat-label">Dominant Land</div>
                        <div class="stat-value" id="stat-landuse">--</div>
                    </div>
                    <div class="stat-card" style="border-color: rgba(245,158,11,0.5);">
                        <div class="stat-label">Flood Zone</div>
                        <div class="stat-value" id="stat-flood-overlap">--</div>
                        <div class="stat-subtext" id="stat-flood-zone"></div>
                    </div>
                    <div class="stat-card" style="border-color: #3b82f6;">
                        <div class="stat-label">Wetlands</div>
                        <div class="stat-value" id="stat-wet-count">0</div>
                    </div>
                    <div class="stat-card" style="border-color: #dc2626;">
                        <div class="stat-label">Critical Habitat</div>
                        <div class="stat-value" id="stat-crithab-count">0</div>
                        <div class="stat-subtext" id="stat-crithab-status"></div>
                    </div>
                    <div class="stat-card" style="border-color: #fbbf24;">
                        <div class="stat-label">Solar GHI</div>
                        <div class="stat-value" id="stat-solar-ghi">--</div>
                        <div class="stat-subtext" id="stat-solar-rating"></div>
                    </div>
                </div>

                <!-- Fatal Flaws Banner -->
                <div class="fatal-flaw-banner" id="fatal-flaw-banner">
                    <div class="fatal-flaw-title">üö´ FATAL FLAWS DETECTED</div>
                    <div class="fatal-flaw-list" id="fatal-flaw-list"></div>
                </div>

                <!-- Warnings Banner -->
                <div class="warning-banner" id="warning-banner">
                    <div class="warning-title">‚ö†Ô∏è SIGNIFICANT CONCERNS</div>
                    <div class="warning-list" id="warning-list"></div>
                </div>

                <!-- Site Scores -->
                <div style="display: flex; gap: 10px;">
                    <div class="site-score" id="site-score-container" style="flex:1;">
                        <div class="site-score-label">‚òÄÔ∏è Solar Score</div>
                        <div class="site-score-value" id="site-score-value">--</div>
                        <div class="site-score-rating" id="site-score-rating"></div>
                    </div>
                    <div class="site-score" id="dc-score-container" style="flex:1;">
                        <div class="site-score-label">üñ•Ô∏è Data Center Score</div>
                        <div class="site-score-value" id="dc-score-value">--</div>
                        <div class="site-score-rating" id="dc-score-rating"></div>
                    </div>
                </div>

                <div class="tabs-row">
                    <button class="tab-btn active" data-target="infra">Infrastructure Details</button>
                    <button class="tab-btn" data-target="env">Environmental Details</button>
                    <button class="tab-btn" data-target="protected">Protected Lands</button>
                </div>

                <div class="results-body">
                    <div class="results-list" id="res-content"></div>
                    <div class="export-sidebar">
                        <div class="export-header">Export Data</div>
                        <button class="btn-export primary" id="btn-export-summary">üìä Excel Summary Report</button>
                        <button class="btn-export" id="btn-export-geo">üó∫Ô∏è Full GeoJSON Data</button>
                        <button class="btn-export" id="btn-export-env-csv">üåø Environmental CSV</button>
                        <button class="btn-export" id="btn-export-infra-csv">‚ö° Infrastructure CSV</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast" id="toast">Export Complete</div>

    <script>
        // === CONFIG & STATE ===
        const BASEMAP_STYLES = {
            'carto-dark': {
                version: 8,
                sources: {
                    'carto-dark': { type: 'raster', tiles: ['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'], tileSize: 256 }
                },
                layers: [{ id: 'carto-dark', type: 'raster', source: 'carto-dark' }]
            },
            'satellite': {
                version: 8,
                sources: {
                    'esri-sat': { type: 'raster', tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'], tileSize: 256 }
                },
                layers: [{ id: 'esri-sat', type: 'raster', source: 'esri-sat' }]
            }
        };

        let currentBasemap = 'carto-dark';

        const map = new maplibregl.Map({
            container: 'map',
            style: BASEMAP_STYLES['carto-dark'],
            center: [-98.5, 39.5], zoom: 4
        });
        map.addControl(new maplibregl.NavigationControl(), 'top-right');
        
        function setupAnalysisLayers() {
            // Add sources if missing
            ['buff_inf','buff_env','lyr_trans','lyr_sub','lyr_pipe','lyr_wet','lyr_flood','lyr_prot','lyr_crithab_final','lyr_crithab_proposed'].forEach(id => {
                if (!map.getSource(id)) {
                    map.addSource(id, {
                        type: 'geojson',
                        data: { type: 'FeatureCollection', features: [] }
                    });
                }
            });
            
            // National Flood Data tiles
            if (!map.getSource('nflood_tiles')) {
                map.addSource('nflood_tiles', {
                    type: 'vector',
                    tiles: [
                        'https://api.nationalflooddata.com/v3/specialized/floodtiles1/{z}/{x}/{y}.pbf?x-api-key=cdXEOPkdCoiYUPQ4JN9f6VcpoNi3qxl8cGZRUbBi'
                    ],
                    minzoom: 0,
                    maxzoom: 22
                });
            }
            
            // National Wetlands
            if (!map.getSource('wetlands_mapright')) {
                map.addSource('wetlands_mapright', {
                    type: 'vector',
                    tiles: [
                        'https://a.tiles.mapbox.com/v4/mapright2.Wetlands_HI_20231027_1698423129,mapright2.Wetlands_AK3_20231030_1698732312,mapright2.Wetlands_3_20231030_1698776568,mapright2.Wetlands_AK1_20231030_1698702921,mapright2.Wetlands_AK2_20231030_1698730908,mapright2.Wetlands_1_20231107_1699493429,mapright2.Wetlands_2_20231107_1699449165,mapright2.Wetlands_Rip_20231113_1699903114/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1IjoibWFwcmlnaHQyIiwiYSI6IkpMTE8tT0EifQ.BVYqz1Tp-th28TXPgg3rrQ',
                        'https://b.tiles.mapbox.com/v4/mapright2.Wetlands_HI_20231027_1698423129,mapright2.Wetlands_AK3_20231030_1698732312,mapright2.Wetlands_3_20231030_1698776568,mapright2.Wetlands_AK1_20231030_1698702921,mapright2.Wetlands_AK2_20231030_1698730908,mapright2.Wetlands_1_20231107_1699493429,mapright2.Wetlands_2_20231107_1699449165,mapright2.Wetlands_Rip_20231113_1699903114/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1IjoibWFwcmlnaHQyIiwiYSI6IkpMTE8tT0EifQ.BVYqz1Tp-th28TXPgg3rrQ'
                    ],
                    minzoom: 12,
                    maxzoom: 14
                });
            }
            
            // NFHL Flood source (will be populated on query)
            if (!map.getSource('nfhl_flood')) {
                map.addSource('nfhl_flood', {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features: [] }
                });
            }

            // Add layers if missing
            if (!map.getLayer('fill_buff_inf')) {
                map.addLayer({ id: 'fill_buff_inf', type: 'fill', source: 'buff_inf',
                    paint: { 'fill-color': '#06b6d4', 'fill-opacity': 0.08 } });
            }
            if (!map.getLayer('line_buff_inf')) {
                map.addLayer({ id: 'line_buff_inf', type: 'line', source: 'buff_inf',
                    paint: { 'line-color': '#06b6d4', 'line-width': 1, 'line-dasharray':[4,2] } });
            }
            if (!map.getLayer('fill_buff_env')) {
                map.addLayer({ id: 'fill_buff_env', type: 'fill', source: 'buff_env',
                    paint: { 'fill-color': '#10b981', 'fill-opacity': 0.15 } });
            }
            if (!map.getLayer('line_buff_env')) {
                map.addLayer({ id: 'line_buff_env', type: 'line', source: 'buff_env',
                    paint: { 'line-color': '#10b981', 'line-width': 2 } });
            }

            if (!map.getLayer('d_wet')) {
                map.addLayer({ id: 'd_wet', type: 'fill', source: 'lyr_wet',
                    paint: { 'fill-color': '#3b82f6', 'fill-opacity': 0.4 } });
            }
            if (!map.getLayer('d_flood')) {
                map.addLayer({ id: 'd_flood', type: 'fill', source: 'lyr_flood',
                    paint: { 'fill-color': '#f59e0b', 'fill-opacity': 0.4 } });
            }
            if (!map.getLayer('d_prot')) {
                map.addLayer({ id: 'd_prot', type: 'fill', source: 'lyr_prot',
                    paint: { 'fill-color': '#8b5cf6', 'fill-opacity': 0.3 } });
            }
            if (!map.getLayer('d_crithab_final')) {
                map.addLayer({ id: 'd_crithab_final', type: 'fill', source: 'lyr_crithab_final',
                    paint: { 'fill-color': '#dc2626', 'fill-opacity': 0.4 } });
            }
            if (!map.getLayer('d_crithab_final_line')) {
                map.addLayer({ id: 'd_crithab_final_line', type: 'line', source: 'lyr_crithab_final',
                    paint: { 'line-color': '#991b1b', 'line-width': 2 } });
            }
            if (!map.getLayer('d_crithab_proposed')) {
                map.addLayer({ id: 'd_crithab_proposed', type: 'fill', source: 'lyr_crithab_proposed',
                    paint: { 'fill-color': '#f472b6', 'fill-opacity': 0.35 },
                    layout: { 'visibility': 'none' } });
            }
            if (!map.getLayer('d_crithab_proposed_line')) {
                map.addLayer({ id: 'd_crithab_proposed_line', type: 'line', source: 'lyr_crithab_proposed',
                    paint: { 'line-color': '#db2777', 'line-width': 2, 'line-dasharray': [4, 2] },
                    layout: { 'visibility': 'none' } });
            }
            if (!map.getLayer('d_pipe')) {
                map.addLayer({ id: 'd_pipe', type: 'line', source: 'lyr_pipe',
                    paint: { 'line-color': '#f97316', 'line-width': 2 } });
            }
            if (!map.getLayer('d_trans')) {
                map.addLayer({
                    id: 'd_trans',
                    type: 'line',
                    source: 'lyr_trans',
                    paint: {
                        'line-color': ['match', ['get', 'voltage_rank'],
                            1, '#6366f1',
                            2, '#8b5cf6',
                            3, '#22d3ee',
                            4, '#4ade80',
                            5, '#facc15',
                            6, '#fb923c',
                            7, '#f472b6',
                            '#6366f1'
                        ],
                        'line-width': ['interpolate', ['linear'], ['zoom'], 5, 1.5, 12, 3]
                    }
                });
            }
            if (!map.getLayer('d_sub')) {
                map.addLayer({ id: 'd_sub', type: 'circle', source: 'lyr_sub',
                    paint: {
                        'circle-color': '#f43f5e',
                        'circle-radius': 5,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#fff'
                    } 
                });
            }
            
            // National Flood Data overlay (default hidden)
            if (!map.getLayer('nflood_floodzones')) {
                map.addLayer({
                    id: 'nflood_floodzones',
                    type: 'fill',
                    source: 'nflood_tiles',
                    'source-layer': 'default',
                    paint: {
                        'fill-color': '#f97316',
                        'fill-opacity': 0.35
                    },
                    layout: { 'visibility': 'none' }
                });
            }

            // National Wetlands overlays (default hidden)
            const MAPRIGHT_WETLAND_LAYERS = [
                'Wetlands_HI_20231027_1698423063.5217037',
                'Wetlands_AK3_20231030_1698731010.392679',
                'Wetlands_3_20231030_1698768698.5538049',
                'Wetlands_AK1_20231030_1698701662.3827837',
                'Wetlands_AK2_20231030_1698730585.397208',
                'Wetlands_1_20231107_1699472081.0077796',
                'Wetlands_2_20231107_1699427262.9916897',
                'Wetlands_Rip_20231113_1699902696.01962'
            ];

            MAPRIGHT_WETLAND_LAYERS.forEach((srcLayerId, idx) => {
                const layerId = `wetlands_mapright_${idx}`;
                if (!map.getLayer(layerId)) {
                    map.addLayer({
                        id: layerId,
                        type: 'fill',
                        source: 'wetlands_mapright',
                        'source-layer': srcLayerId,
                        paint: {
                            'fill-color': '#3b82f6',
                            'fill-opacity': 0.35
                        },
                        layout: { 'visibility': 'none' }
                    }, 'd_wet');
                }
            });
            
            // NFHL Flood layer (default hidden)
            if (!map.getLayer('nfhl_flood')) {
                map.addLayer({
                    id: 'nfhl_flood',
                    type: 'fill',
                    source: 'nfhl_flood',
                    paint: {
                        'fill-color': '#fb923c',
                        'fill-opacity': 0.4
                    },
                    layout: { 'visibility': 'none' }
                });
            }
        }

        function restoreAnalysisData() {
            if (!currentData) return;

            // Restore feature data
            if (map.getSource('lyr_wet')) {
                map.getSource('lyr_wet').setData({
                    type: 'FeatureCollection',
                    features: currentData.env.wetlands
                });
            }
            if (map.getSource('lyr_flood')) {
                map.getSource('lyr_flood').setData({
                    type: 'FeatureCollection',
                    features: currentData.env.flood
                });
            }
            if (map.getSource('lyr_prot')) {
                map.getSource('lyr_prot').setData({
                    type: 'FeatureCollection',
                    features: currentData.env.protected
                });
            }
            if (map.getSource('lyr_crithab_final')) {
                map.getSource('lyr_crithab_final').setData({
                    type: 'FeatureCollection',
                    features: currentData.env.crithabFinal
                });
            }
            if (map.getSource('lyr_crithab_proposed')) {
                map.getSource('lyr_crithab_proposed').setData({
                    type: 'FeatureCollection',
                    features: currentData.env.crithabProposed
                });
            }
            if (map.getSource('lyr_trans')) {
                map.getSource('lyr_trans').setData({
                    type: 'FeatureCollection',
                    features: currentData.infra.trans
                });
            }
            if (map.getSource('lyr_sub')) {
                map.getSource('lyr_sub').setData({
                    type: 'FeatureCollection',
                    features: currentData.infra.subs
                });
            }
            if (map.getSource('lyr_pipe')) {
                map.getSource('lyr_pipe').setData({
                    type: 'FeatureCollection',
                    features: currentData.infra.pipe
                });
            }

            // Restore buffers if we have a previous analysis point
            if (lastCoords && map.getSource('buff_inf') && map.getSource('buff_env')) {
                const buffInfra = createBufferFeature([lastCoords.lng, lastCoords.lat], radInfra, bufferShape);
                const buffEnv   = createBufferFeature([lastCoords.lng, lastCoords.lat], radEnv, bufferShape);
                map.getSource('buff_inf').setData(buffInfra);
                map.getSource('buff_env').setData(buffEnv);
            }
        }
  
        function setBasemapStyle(styleKey) {
            if (styleKey === currentBasemap) return;
            currentBasemap = styleKey;

            const center = map.getCenter();
            const zoom = map.getZoom();

            map.setStyle(BASEMAP_STYLES[styleKey]);

            // Wait for the new style to be ready, then re-attach analysis layers + data
            const handleStyleData = () => {
                if (!map.isStyleLoaded()) {
                    setTimeout(handleStyleData, 50);
                    return;
                }

                map.setCenter(center);
                map.setZoom(zoom);

                setupAnalysisLayers();
                restoreAnalysisData();
            };

            map.once('styledata', handleStyleData);
        }

        let radInfra = 2.0;
        let radEnv = 0.25;
        let bufferShape = 'circle';
        let lastCoords = null;
        let currentData = null;
        let currentTab = 'infra';
        let currentMarker = null;

        const SERVICE_URLS = {
            wetlands: 'https://fwspublicservices.wim.usgs.gov/wetlandsmapservice/rest/services/Wetlands/MapServer/0/query',
            flood: 'https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Flood_Hazard_Reduced_Set_gdb/FeatureServer/0/query',
            nfhl_flood: 'https://hazards.fema.gov/arcgis/rest/services/public/NFHL/MapServer/28/query',
            protected: 'https://services.arcgis.com/v01gqwM5QqNysAAi/arcgis/rest/services/Manager_Name/FeatureServer/0/query',
            crithab_final_poly: 'https://services.arcgis.com/QVENGdaPbd4LUkLV/ArcGIS/rest/services/USFWS_Critical_Habitat/FeatureServer/0/query',
            crithab_final_line: 'https://services.arcgis.com/QVENGdaPbd4LUkLV/ArcGIS/rest/services/USFWS_Critical_Habitat/FeatureServer/1/query',
            crithab_proposed_poly: 'https://services.arcgis.com/QVENGdaPbd4LUkLV/ArcGIS/rest/services/USFWS_Critical_Habitat/FeatureServer/2/query',
            crithab_proposed_line: 'https://services.arcgis.com/QVENGdaPbd4LUkLV/ArcGIS/rest/services/USFWS_Critical_Habitat/FeatureServer/3/query',
            trans: 'https://services2.arcgis.com/FiaPA4ga0iQKduv3/arcgis/rest/services/US_Electric_Power_Transmission_Lines/FeatureServer/0/query',
            subs: 'https://services6.arcgis.com/OO2s4OoyCZkYJ6oE/arcgis/rest/services/Substations/FeatureServer/0/query',
            pipe: 'https://services2.arcgis.com/FiaPA4ga0iQKduv3/arcgis/rest/services/Natural_Gas_Interstate_and_Intrastate_Pipelines_1/FeatureServer/0/query',
            solar: 'https://developer.nrel.gov/api/solar/solar_resource/v1.json'
        };

        const NREL_API_KEY = 'zXdbmYJ49pr7aQkN1WktVYVPASCDQRQZykTFa3pd';

        // Fatal flaw definitions
        const FATAL_FLOOD_ZONES = ['A', 'AE', 'AH', 'AO', 'V', 'VE', 'AR'];
        const FATAL_PROTECTED_TYPES = ['Wilderness', 'National Park', 'National Monument', 'Wildlife Refuge', 'Wild and Scenic River', 'Marine Protected Area'];
        const HIGH_RISK_WETLAND_ACRES = 3;

        const NLCD_CLASSES = { 11:'Water', 21:'Developed Open', 22:'Developed Low', 23:'Developed Med', 24:'Developed High', 31:'Barren', 41:'Forest Decid', 42:'Forest Everg', 43:'Forest Mix', 52:'Shrub', 71:'Grassland', 81:'Pasture', 82:'Crops', 90:'Wetlands Woody', 95:'Wetlands Herb' };

        function getFloodZoneDesc(zone) {
            const descs = { 'A': 'High Risk', 'AE': 'High Risk (BFE)', 'AH': 'Shallow Flooding', 'AO': 'Sheet Flow', 'V': 'Coastal High Risk', 'VE': 'Coastal (BFE)', 'X': 'Moderate/Low Risk', 'D': 'Undetermined' };
            return descs[zone] || zone || 'Unknown';
        }

        function getVoltageRank(vc) {
            if (!vc) return 1;
            const v = String(vc).toUpperCase();
            if (v.includes('DC')) return 7;
            if (v.includes('735') || v.includes('765') || v.includes('1000')) return 6;
            if (v.includes('500')) return 5;
            if (v.includes('345')) return 4;
            if (v.includes('220') || v.includes('230') || v.includes('287')) return 3;
            if (v.includes('100') || v.includes('115') || v.includes('138') || v.includes('161')) return 2;
            return 1;
        }

        function getVoltageCategory(vc) {
            if (!vc) return 'Unknown';
            const v = String(vc).toUpperCase();
            if (v.includes('DC')) return 'DC';
            if (v.includes('735') || v.includes('765') || v.includes('1000')) return '735+ kV';
            if (v.includes('500')) return '500 kV';
            if (v.includes('345')) return '345 kV';
            if (v.includes('220') || v.includes('230') || v.includes('287')) return '220-287 kV';
            if (v.includes('100') || v.includes('115') || v.includes('138') || v.includes('161')) return '100-161 kV';
            return '<100 kV';
        }

        const voltageColors = {
            1: '#6366f1',
            2: '#8b5cf6',
            3: '#22d3ee',
            4: '#4ade80',
            5: '#facc15',
            6: '#fb923c',
            7: '#f472b6'
        };

        // === MAP LAYERS INIT ===

        map.on('load', () => {
            setupAnalysisLayers();
        });
        
        // === UI HANDLERS ===
        document.getElementById('slider-infra').addEventListener('input', e => {
            radInfra = parseFloat(e.target.value);
            document.getElementById('val-infra').innerText = radInfra + " mi";
        });
        document.getElementById('slider-env').addEventListener('input', e => {
            radEnv = parseFloat(e.target.value);
            document.getElementById('val-env').innerText = radEnv + " mi";
        });

        document.querySelectorAll('input[name="buffer-shape"]').forEach(r => {
            r.addEventListener('change', () => { bufferShape = r.value; });
        });

        document.getElementById('search-btn').addEventListener('click', doSearch);
        document.getElementById('search-input').addEventListener('keypress', e => { if(e.key === 'Enter') doSearch(); });

        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTab = btn.dataset.target;
                renderResultsList();
            });
        });

        document.querySelectorAll('.layer-toggle').forEach(t => {
            t.addEventListener('click', () => {
                const cb = t.querySelector('.layer-checkbox');
                const isBasemapToggle = t.dataset.layer === 'basemap';

                if (isBasemapToggle) {
                    const styleKey = t.dataset.style;
                    if (!cb.classList.contains('checked')) {
                        setBasemapStyle(styleKey);
                        document.querySelectorAll('.layer-toggle[data-layer="basemap"] .layer-checkbox').forEach(b => b.classList.remove('checked'));
                        cb.classList.add('checked');
                    }
                    return;
                }

                cb.classList.toggle('checked');
                const layerName = t.dataset.layer;
                
                // Handle the new layers
                if (layerName === 'wetlands_mapright') {
                    // Toggle all 8 wetlands_mapright layers
                    const visibility = cb.classList.contains('checked') ? 'visible' : 'none';
                    for (let i = 0; i < 8; i++) {
                        const lyrId = `wetlands_mapright_${i}`;
                        if (map.getLayer(lyrId)) {
                            map.setLayoutProperty(lyrId, 'visibility', visibility);
                        }
                    }
                } else if (layerName === 'nflood_floodzones') {
                    if (map.getLayer('nflood_floodzones')) {
                        map.setLayoutProperty('nflood_floodzones', 'visibility', 
                            cb.classList.contains('checked') ? 'visible' : 'none');
                    }
                } else if (layerName === 'nfhl_flood') {
                    if (map.getLayer('nfhl_flood')) {
                        map.setLayoutProperty('nfhl_flood', 'visibility', 
                            cb.classList.contains('checked') ? 'visible' : 'none');
                    }
                } else if (layerName === 'crithab_final') {
                    const visibility = cb.classList.contains('checked') ? 'visible' : 'none';
                    if (map.getLayer('d_crithab_final')) {
                        map.setLayoutProperty('d_crithab_final', 'visibility', visibility);
                    }
                    if (map.getLayer('d_crithab_final_line')) {
                        map.setLayoutProperty('d_crithab_final_line', 'visibility', visibility);
                    }
                } else if (layerName === 'crithab_proposed') {
                    const visibility = cb.classList.contains('checked') ? 'visible' : 'none';
                    if (map.getLayer('d_crithab_proposed')) {
                        map.setLayoutProperty('d_crithab_proposed', 'visibility', visibility);
                    }
                    if (map.getLayer('d_crithab_proposed_line')) {
                        map.setLayoutProperty('d_crithab_proposed_line', 'visibility', visibility);
                    }
                } else {
                    // Handle existing layers
                    const mapLyrId = { 
                        'wetlands': 'd_wet', 
                        'floodzone': 'd_flood', 
                        'protected': 'd_prot', 
                        'transmission': 'd_trans', 
                        'substations': 'd_sub', 
                        'pipelines': 'd_pipe' 
                    }[layerName];
                    
                    if(mapLyrId && map.getLayer(mapLyrId)) {
                        map.setLayoutProperty(mapLyrId, 'visibility', 
                            cb.classList.contains('checked') ? 'visible' : 'none');
                    }
                }
            });
        });

        document.getElementById('btn-export-summary').addEventListener('click', exportExcelSummary);
        document.getElementById('btn-export-geo').addEventListener('click', exportGeoJSON);
        document.getElementById('btn-export-env-csv').addEventListener('click', () => exportCSV('env'));
        document.getElementById('btn-export-infra-csv').addEventListener('click', () => exportCSV('infra'));

        // === BUFFER GEOMETRY ===
        function createBuffer(center, radiusMiles, shape) {
            const pt = turf.point(center);
            if (shape === 'square') {
                const dist = radiusMiles * 1.60934;
                return turf.square(turf.bbox(turf.buffer(pt, dist, {units: 'kilometers'})));
            }
            return turf.circle(pt, radiusMiles, {units: 'miles'});
        }

        function createBufferFeature(center, radiusMiles, shape) {
            const pt = turf.point(center);
            if (shape === 'square') {
                const dist = radiusMiles * 1.60934;
                const buffered = turf.buffer(pt, dist, {units: 'kilometers'});
                const bbox = turf.square(turf.bbox(buffered));
                return turf.bboxPolygon(bbox);
            }
            return turf.circle(pt, radiusMiles, {units: 'miles'});
        }

        // === SEARCH & ANALYSIS ===
        async function doSearch() {
            const query = document.getElementById('search-input').value;
            if(!query) return;

            const coordMatch = query.match(/^(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)$/);
            if(coordMatch) {
                goToLocation(parseFloat(coordMatch[2]), parseFloat(coordMatch[1]));
            } else {
                try {
                    const r = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1&countrycodes=us`);
                    const d = await r.json();
                    if(!d.length) { alert("Location not found"); return; }
                    goToLocation(parseFloat(d[0].lon), parseFloat(d[0].lat));
                } catch(e) { alert("Search error"); return; }
            }
        }

        // Expanded search radius for infrastructure when none found in initial buffer
        const EXPANDED_INFRA_RADIUS = 10; // miles - search up to 15 miles for transmission/substations

        async function goToLocation(lng, lat) {
            lastCoords = {lng, lat};
            map.flyTo({ center: [lng, lat], zoom: 13 });
            
            if(currentMarker) currentMarker.remove();
            const el = document.createElement('div');
            el.style.cssText = 'width:20px;height:20px;background:#10b981;border-radius:50%;border:3px solid white;box-shadow:0 0 0 3px rgba(16,185,129,0.3)';
            currentMarker = new maplibregl.Marker(el).setLngLat([lng, lat]).addTo(map);

            const buffInfra = createBufferFeature([lng, lat], radInfra, bufferShape);
            const buffEnv = createBufferFeature([lng, lat], radEnv, bufferShape);
            
            map.getSource('buff_inf').setData(buffInfra);
            map.getSource('buff_env').setData(buffEnv);

            document.getElementById('loading').classList.add('active');
            
            try {
                const bboxEnv = turf.bbox(buffEnv);
                const bboxInf = turf.bbox(buffInfra);
                
                // Initial query with user-selected buffer
                let [wet, flood, prot, land, trans, sub, pipe, nfhlFlood, crithabFinalPoly, crithabFinalLine, crithabProposedPoly, crithabProposedLine, solarData] = await Promise.all([
                    queryEsri(SERVICE_URLS.wetlands, bboxEnv),
                    queryEsri(SERVICE_URLS.flood, bboxEnv),
                    queryEsri(SERVICE_URLS.protected, bboxEnv),
                    sampleNLCD(lng, lat),
                    queryEsri(SERVICE_URLS.trans, bboxInf),
                    queryEsri(SERVICE_URLS.subs, bboxInf),
                    queryEsri(SERVICE_URLS.pipe, bboxInf),
                    queryEsri(SERVICE_URLS.nfhl_flood, bboxEnv),
                    queryEsri(SERVICE_URLS.crithab_final_poly, bboxEnv),
                    queryEsri(SERVICE_URLS.crithab_final_line, bboxEnv),
                    queryEsri(SERVICE_URLS.crithab_proposed_poly, bboxEnv),
                    queryEsri(SERVICE_URLS.crithab_proposed_line, bboxEnv),
                    querySolarResource(lng, lat)
                ]);

                // EXPANDED SEARCH: If no transmission or substations found, search wider area
                let expandedSearchUsed = false;
                if(trans.length === 0 || sub.length === 0) {
                    const expandedBuff = createBufferFeature([lng, lat], EXPANDED_INFRA_RADIUS, 'circle');
                    const bboxExpanded = turf.bbox(expandedBuff);
                    
                    if(trans.length === 0) {
                        console.log(`No transmission in ${radInfra}mi buffer, expanding search to ${EXPANDED_INFRA_RADIUS}mi...`);
                        trans = await queryEsri(SERVICE_URLS.trans, bboxExpanded);
                        if(trans.length > 0) expandedSearchUsed = true;
                    }
                    if(sub.length === 0) {
                        console.log(`No substations in ${radInfra}mi buffer, expanding search to ${EXPANDED_INFRA_RADIUS}mi...`);
                        sub = await queryEsri(SERVICE_URLS.subs, bboxExpanded);
                        if(sub.length > 0) expandedSearchUsed = true;
                    }
                }

                const safeIntersects = (f, geom) => {
                    if(!f || !f.geometry) return false;
                    try { return turf.booleanIntersects(f, geom); } catch(e){ return false; }
                };
                const safePointInPoly = (f, geom) => {
                    if(!f || !f.geometry) return false;
                    try { return turf.booleanPointInPolygon(f, geom); } catch(e){ return false; }
                };

                // For infrastructure, include features from expanded search for scoring purposes
                // but only display features within the user-selected buffer on the map
                const pt = turf.point([lng, lat]);

                // Process all transmission lines (including expanded search) with distance calculation
                const allTransWithDist = trans.map(f => {
                    let dist = Infinity;
                    try { 
                        if(f.geometry) { 
                            const n = turf.nearestPointOnLine(f, pt, {units:'miles'}); 
                            dist = n.properties.dist; 
                        } 
                    } catch(e){}
                    return {
                        ...f,
                        properties: {
                            ...f.properties,
                            voltage_rank: getVoltageRank(f.properties?.VOLTAGE || f.properties?.VOLT_CLASS),
                            voltage_category: getVoltageCategory(f.properties?.VOLTAGE || f.properties?.VOLT_CLASS),
                            _distance: dist
                        }
                    };
                }).filter(f => f.properties._distance <= EXPANDED_INFRA_RADIUS);

                // Process all substations with distance calculation
                const allSubsWithDist = sub.map(f => {
                    let dist = Infinity;
                    try { if(f.geometry) { dist = turf.distance(pt, f, {units:'miles'}); } } catch(e){}
                    return {
                        ...f,
                        properties: {
                            ...f.properties,
                            _distance: dist
                        }
                    };
                }).filter(f => f.properties._distance <= EXPANDED_INFRA_RADIUS);

                currentData = {
                    env: {
                        wetlands: wet.filter(f => safeIntersects(f, buffEnv)),
                        flood: flood.filter(f => safeIntersects(f, buffEnv)),
                        protected: prot.filter(f => safeIntersects(f, buffEnv)),
                        crithabFinal: [...crithabFinalPoly, ...crithabFinalLine].filter(f => safeIntersects(f, buffEnv)).map(f => ({...f, properties: {...f.properties, status: 'Final'}})),
                        crithabProposed: [...crithabProposedPoly, ...crithabProposedLine].filter(f => safeIntersects(f, buffEnv)).map(f => ({...f, properties: {...f.properties, status: 'Proposed'}})),
                        landuse: land
                    },
                    infra: {
                        // Store ALL infrastructure for scoring (up to expanded radius)
                        trans: allTransWithDist,
                        subs: allSubsWithDist,
                        pipe: pipe.filter(f => safeIntersects(f, buffInfra)),
                        // Also store what's in the display buffer for map rendering
                        transInBuffer: allTransWithDist.filter(f => f.properties._distance <= radInfra),
                        subsInBuffer: allSubsWithDist.filter(f => f.properties._distance <= radInfra)
                    },
                    solar: solarData,
                    expandedSearchUsed: expandedSearchUsed
                };

                // Display only features within user-selected buffer on map
                map.getSource('lyr_wet').setData({type:'FeatureCollection', features: currentData.env.wetlands});
                map.getSource('lyr_flood').setData({type:'FeatureCollection', features: currentData.env.flood});
                map.getSource('lyr_prot').setData({type:'FeatureCollection', features: currentData.env.protected});
                map.getSource('lyr_crithab_final').setData({type:'FeatureCollection', features: currentData.env.crithabFinal});
                map.getSource('lyr_crithab_proposed').setData({type:'FeatureCollection', features: currentData.env.crithabProposed});
                map.getSource('lyr_trans').setData({type:'FeatureCollection', features: currentData.infra.transInBuffer});
                map.getSource('lyr_sub').setData({type:'FeatureCollection', features: currentData.infra.subsInBuffer});
                map.getSource('lyr_pipe').setData({type:'FeatureCollection', features: currentData.infra.pipe});
                
                // Update NFHL flood source
                const nfhlFiltered = nfhlFlood.filter(f => safeIntersects(f, buffEnv));
                map.getSource('nfhl_flood').setData({type:'FeatureCollection', features: nfhlFiltered});

                updateStats();
                renderResultsList();
                
                document.getElementById('res-placeholder').style.display = 'none';
                document.getElementById('res-container').classList.add('active');
                document.getElementById('res-meta').innerText = `${lat.toFixed(4)}, ${lng.toFixed(4)} | Env: ${radEnv}mi | Infra: ${radInfra}mi | ${bufferShape}`;

            } catch(e) {
                console.error(e);
                alert("Analysis failed.");
            } finally {
                document.getElementById('loading').classList.remove('active');
            }
        }

        async function queryEsri(url, bbox) {
            const params = new URLSearchParams({
                f: 'geojson', returnGeometry: 'true', outFields: '*', spatialRel: 'esriSpatialRelIntersects',
                geometry: JSON.stringify({xmin:bbox[0], ymin:bbox[1], xmax:bbox[2], ymax:bbox[3], spatialReference:{wkid:4326}}),
                geometryType: 'esriGeometryEnvelope'
            });
            try {
                const r = await fetch(`${url}?${params}`);
                if(!r.ok) return [];
                const d = await r.json();
                return d.features || [];
            } catch { return []; }
        }

        async function sampleNLCD(lng, lat) {
            const url = 'https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/identify';
            const params = new URLSearchParams({
                f: 'json', geometryType: 'esriGeometryPoint', returnGeometry: 'false',
                geometry: JSON.stringify({x:lng, y:lat, spatialReference:{wkid:4326}})
            });
            try {
                const r = await fetch(`${url}?${params}`);
                const d = await r.json();
                return NLCD_CLASSES[d.value] || "Unknown";
            } catch { return "Unknown"; }
        }

        async function querySolarResource(lng, lat) {
            try {
                const r = await fetch(`${SERVICE_URLS.solar}?api_key=${NREL_API_KEY}&lat=${lat}&lon=${lng}`);
                const d = await r.json();
                if(d.outputs) {
                    return {
                        ghi: d.outputs.avg_ghi?.annual || null,
                        dni: d.outputs.avg_dni?.annual || null,
                        tilt: d.outputs.avg_lat_tilt?.annual || null
                    };
                }
                return { ghi: null, dni: null, tilt: null };
            } catch { return { ghi: null, dni: null, tilt: null }; }
        }

        function getSolarRating(ghi) {
            if(!ghi) return { rating: 'Unknown', color: '#6b7280' };
            if(ghi >= 5.5) return { rating: 'Excellent', color: '#06b6d4' };
            if(ghi >= 5.0) return { rating: 'Very Good', color: '#22c55e' };
            if(ghi >= 4.5) return { rating: 'Good', color: '#84cc16' };
            if(ghi >= 4.0) return { rating: 'Fair', color: '#eab308' };
            if(ghi >= 3.5) return { rating: 'Poor', color: '#f97316' };
            return { rating: 'Very Poor', color: '#ef4444' };
        }

        function analyzeFatalFlaws() {
            const flaws = [];
            const warnings = [];
            const pt = turf.point([lastCoords.lng, lastCoords.lat]);
            
            // Check Critical Habitat (Final) - FATAL if point inside
            currentData.env.crithabFinal.forEach(f => {
                try {
                    if(f.geometry && f.geometry.type && f.geometry.type.includes('Polygon') && turf.booleanPointInPolygon(pt, f)) {
                        flaws.push(`Point inside Final Critical Habitat for ${f.properties?.comname || 'protected species'} - ESA Section 7 consultation required`);
                    }
                } catch(e) {}
            });
            
            // Check Critical Habitat (Proposed) - Warning if point inside
            currentData.env.crithabProposed.forEach(f => {
                try {
                    if(f.geometry && f.geometry.type && f.geometry.type.includes('Polygon') && turf.booleanPointInPolygon(pt, f)) {
                        warnings.push(`Point inside Proposed Critical Habitat for ${f.properties?.comname || 'species'} - likely to become Final`);
                    }
                } catch(e) {}
            });
            
            // Check Flood Zones - FATAL for high-risk zones
            currentData.env.flood.forEach(f => {
                try {
                    if(turf.booleanPointInPolygon(pt, f)) {
                        const zone = f.properties?.FLD_ZONE;
                        if(FATAL_FLOOD_ZONES.includes(zone)) {
                            flaws.push(`Point inside ${zone} Flood Zone (${getFloodZoneDesc(zone)}) - uninsurable for data center`);
                        }
                    }
                } catch(e) {}
            });
            
            // Check Protected Areas - FATAL for certain types
            currentData.env.protected.forEach(f => {
                try {
                    if(f.geometry && f.geometry.type && f.geometry.type.includes('Polygon') && turf.booleanPointInPolygon(pt, f)) {
                        const designation = f.properties?.Des_Tp || f.properties?.Mang_Name || '';
                        const name = f.properties?.Unit_Nm || 'Protected Area';
                        const isFatal = FATAL_PROTECTED_TYPES.some(t => designation.toLowerCase().includes(t.toLowerCase()) || name.toLowerCase().includes(t.toLowerCase()));
                        if(isFatal) {
                            flaws.push(`Point inside ${name} (${designation}) - development prohibited`);
                        } else {
                            warnings.push(`Point inside ${name} - may have development restrictions`);
                        }
                    }
                } catch(e) {}
            });
            
            // Check Wetlands - Warning for large wetland areas
            let totalWetlandAcres = 0;
            currentData.env.wetlands.forEach(f => {
                totalWetlandAcres += parseFloat(f.properties?.ACRES || 0);
            });
            if(totalWetlandAcres > HIGH_RISK_WETLAND_ACRES) {
                warnings.push(`${totalWetlandAcres.toFixed(1)} acres of wetlands nearby - Individual 404 permit likely required (12-24 months, $500K+ mitigation)`);
            } else if(totalWetlandAcres > 0.5) {
                warnings.push(`${totalWetlandAcres.toFixed(1)} acres of wetlands nearby - Section 404 permit required`);
            }
            
            // Check Transmission Distance - FATAL if too far
            let nearestTransDist = Infinity;
            currentData.infra.trans.forEach(f => {
                try {
                    if(f.geometry) {
                        const n = turf.nearestPointOnLine(f, pt, {units:'miles'});
                        if(n.properties.dist < nearestTransDist) nearestTransDist = n.properties.dist;
                    }
                } catch(e) {}
            });
            if(nearestTransDist > 15) {
                flaws.push(`No transmission lines within 15 miles (nearest: ${nearestTransDist.toFixed(1)} mi) - interconnection likely uneconomic`);
            } else if(nearestTransDist > 10) {
                warnings.push(`Transmission lines ${nearestTransDist.toFixed(1)} miles away - significant gen-tie costs ($15-40M+)`);
            } else if(nearestTransDist > 5) {
                warnings.push(`Transmission lines ${nearestTransDist.toFixed(1)} miles away - moderate gen-tie costs ($5-15M)`);
            }
            
            // Check Substation Distance - FATAL if too far
            let nearestSubDist = Infinity;
            currentData.infra.subs.forEach(f => {
                if(f.geometry) {
                    const d = turf.distance(pt, f, {units:'miles'});
                    if(d < nearestSubDist) nearestSubDist = d;
                }
            });
            if(nearestSubDist > 25) {
                flaws.push(`No substations within 25 miles (nearest: ${nearestSubDist.toFixed(1)} mi) - new substation required ($20-100M+)`);
            } else if(nearestSubDist > 15) {
                warnings.push(`Nearest substation ${nearestSubDist.toFixed(1)} miles away - may need significant infrastructure investment`);
            }
            
            // Check Solar Resource for solar projects
            if(currentData.solar?.ghi && currentData.solar.ghi < 4.0) {
                warnings.push(`Low solar resource (GHI: ${currentData.solar.ghi.toFixed(2)} kWh/m¬≤/day) - challenging economics for solar`);
            }
            
            return { flaws, warnings };
        }

        // NLCD code to category mapping
        const NLCD_CODES = {
            'Open Water': 11, 'Perennial Ice/Snow': 12, 'Developed, Open Space': 21,
            'Developed, Low Intensity': 22, 'Developed, Medium Intensity': 23, 'Developed, High Intensity': 24,
            'Barren Land': 31, 'Deciduous Forest': 41, 'Evergreen Forest': 42, 'Mixed Forest': 43,
            'Shrub/Scrub': 52, 'Grassland/Herbaceous': 71, 'Pasture/Hay': 81, 'Cultivated Crops': 82,
            'Woody Wetlands': 90, 'Emergent Herbaceous Wetlands': 95
        };

        function getNLCDCode(landuse) {
            return NLCD_CODES[landuse] || 0;
        }

        function calculateDetailedScores() {
            const pt = turf.point([lastCoords.lng, lastCoords.lat]);
            const scores = { solar: { breakdown: {}, total: 0, fatal: false, fatalReason: '' }, dc: { breakdown: {}, total: 0, fatal: false, fatalReason: '' } };

            // === HELPER FUNCTIONS ===
            const getMaxVoltage = () => {
                let maxV = 0;
                currentData.infra.trans.forEach(f => {
                    const vRaw = f.properties?.VOLTAGE || f.properties?.VOLT_CLASS || "0";
                    const nums = String(vRaw).match(/\d+/g);
                    if(nums) { const v = Math.max(...nums.map(n=>parseInt(n))); if(v > maxV && v < 999999) maxV = v; }
                });
                return maxV;
            };

            const getNearestTransDist = () => {
                let minD = Infinity;
                currentData.infra.trans.forEach(f => {
                    // Use pre-calculated distance if available
                    if(f.properties?._distance !== undefined) {
                        if(f.properties._distance < minD) minD = f.properties._distance;
                    } else {
                        try { if(f.geometry) { const n = turf.nearestPointOnLine(f, pt, {units:'miles'}); if(n.properties.dist < minD) minD = n.properties.dist; } } catch(e){}
                    }
                });
                return minD;
            };

            const getNearestSubDist = () => {
                let minD = Infinity;
                currentData.infra.subs.forEach(f => { 
                    // Use pre-calculated distance if available
                    if(f.properties?._distance !== undefined) {
                        if(f.properties._distance < minD) minD = f.properties._distance;
                    } else {
                        if(f.geometry) { const d = turf.distance(pt, f, {units:'miles'}); if(d < minD) minD = d; }
                    }
                });
                return minD;
            };

            const getSubsWithin = (miles) => {
                return currentData.infra.subs.filter(f => {
                    if(f.properties?._distance !== undefined) return f.properties._distance <= miles;
                    return f.geometry && turf.distance(pt, f, {units:'miles'}) <= miles;
                }).length;
            };

            const getNearestPipeDist = () => {
                let minD = Infinity;
                currentData.infra.pipe.forEach(f => {
                    try { if(f.geometry) { const n = turf.nearestPointOnLine(f, pt, {units:'miles'}); if(n.properties.dist < minD) minD = n.properties.dist; } } catch(e){}
                });
                return minD;
            };

            const getTotalWetlandAcres = () => {
                let total = 0;
                currentData.env.wetlands.forEach(f => { total += parseFloat(f.properties?.ACRES || 0); });
                return total;
            };

            const isPointInWetland = () => {
                return currentData.env.wetlands.some(f => { try { return turf.booleanPointInPolygon(pt, f); } catch(e) { return false; } });
            };

            const getFloodZoneAtPoint = () => {
                let zone = null;
                currentData.env.flood.forEach(f => { try { if(turf.booleanPointInPolygon(pt, f)) zone = f.properties?.FLD_ZONE; } catch(e){} });
                return zone;
            };

            const isPointInCritHabFinal = () => {
                return currentData.env.crithabFinal.some(f => { try { return f.geometry?.type?.includes('Polygon') && turf.booleanPointInPolygon(pt, f); } catch(e) { return false; } });
            };

            const isPointInCritHabProposed = () => {
                return currentData.env.crithabProposed.some(f => { try { return f.geometry?.type?.includes('Polygon') && turf.booleanPointInPolygon(pt, f); } catch(e) { return false; } });
            };

            const getNearestCritHabFinalDist = () => {
                let minD = Infinity;
                currentData.env.crithabFinal.forEach(f => {
                    try { if(f.geometry) { const d = turf.distance(pt, turf.centroid(f), {units:'miles'}); if(d < minD) minD = d; } } catch(e){}
                });
                return minD;
            };

            const isPointInProtectedFatal = () => {
                return currentData.env.protected.some(f => {
                    try {
                        if(!f.geometry?.type?.includes('Polygon') || !turf.booleanPointInPolygon(pt, f)) return false;
                        const des = (f.properties?.Des_Tp || f.properties?.Mang_Name || '').toLowerCase();
                        return FATAL_PROTECTED_TYPES.some(t => des.includes(t.toLowerCase()));
                    } catch(e) { return false; }
                });
            };

            const isPointInProtectedOther = () => {
                return currentData.env.protected.some(f => {
                    try { return f.geometry?.type?.includes('Polygon') && turf.booleanPointInPolygon(pt, f); } catch(e) { return false; }
                });
            };

            const getNearestProtectedDist = () => {
                let minD = Infinity;
                currentData.env.protected.forEach(f => {
                    try { if(f.geometry) { const d = turf.distance(pt, turf.centroid(f), {units:'miles'}); if(d < minD) minD = d; } } catch(e){}
                });
                return minD;
            };

            // === GET VALUES ===
            const maxVoltage = getMaxVoltage();
            const nearestTransDist = getNearestTransDist();
            const nearestSubDist = getNearestSubDist();
            const nearestPipeDist = getNearestPipeDist();
            const totalWetlandAcres = getTotalWetlandAcres();
            const pointInWetland = isPointInWetland();
            const floodZone = getFloodZoneAtPoint();
            const pointInCritHabFinal = isPointInCritHabFinal();
            const pointInCritHabProposed = isPointInCritHabProposed();
            const nearestCritHabDist = getNearestCritHabFinalDist();
            const pointInProtectedFatal = isPointInProtectedFatal();
            const pointInProtectedOther = isPointInProtectedOther();
            const nearestProtectedDist = getNearestProtectedDist();
            const transCount = currentData.infra.trans.length;
            const subsWithin10 = getSubsWithin(10);
            const ghi = currentData.solar?.ghi || 0;
            const nlcdCode = getNLCDCode(currentData.env.landuse);

            // === SOLAR SCORING (100 points) ===

            // 1. Transmission (15 pts)
            let solarTrans = 0, solarTransReason = '';
            if(nearestTransDist > 10) { scores.solar.fatal = true; scores.solar.fatalReason = 'No transmission within 10 miles'; solarTrans = 0; solarTransReason = 'FATAL: >10 mi'; }
            else if(nearestTransDist <= 0.5 && maxVoltage >= 345) { solarTrans = 15; solarTransReason = `<0.5mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 1 && maxVoltage >= 200) { solarTrans = 12; solarTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 2 && maxVoltage >= 200) { solarTrans = 10; solarTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 2 && maxVoltage < 200) { solarTrans = 8; solarTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 5 && maxVoltage >= 200) { solarTrans = 7; solarTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 5) { solarTrans = 5; solarTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else { solarTrans = 3; solarTransReason = `${nearestTransDist.toFixed(1)}mi away`; }
            scores.solar.breakdown.transmission = { points: solarTrans, max: 15, reason: solarTransReason };

            // 2. Substations (12 pts)
            let solarSub = 0, solarSubReason = '';
            if(nearestSubDist > 20) { scores.solar.fatal = true; scores.solar.fatalReason = 'No substation within 20 miles'; solarSub = 0; solarSubReason = 'FATAL: >20 mi'; }
            else if(nearestSubDist <= 2) { solarSub = 12; solarSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            else if(nearestSubDist <= 5) { solarSub = 9; solarSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            else if(nearestSubDist <= 10) { solarSub = 6; solarSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            else { solarSub = 3; solarSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            scores.solar.breakdown.substation = { points: solarSub, max: 12, reason: solarSubReason };

            // 3. Solar Irradiance (15 pts)
            let solarGHI = 0, solarGHIReason = '';
            if(ghi >= 5.5) { solarGHI = 15; solarGHIReason = `${ghi.toFixed(2)} - Excellent`; }
            else if(ghi >= 5.0) { solarGHI = 12; solarGHIReason = `${ghi.toFixed(2)} - Very Good`; }
            else if(ghi >= 4.5) { solarGHI = 9; solarGHIReason = `${ghi.toFixed(2)} - Good`; }
            else if(ghi >= 4.0) { solarGHI = 6; solarGHIReason = `${ghi.toFixed(2)} - Fair`; }
            else if(ghi >= 3.5) { solarGHI = 3; solarGHIReason = `${ghi.toFixed(2)} - Poor`; }
            else { solarGHI = 0; solarGHIReason = ghi > 0 ? `${ghi.toFixed(2)} - Very Poor` : 'No data'; }
            scores.solar.breakdown.solarResource = { points: solarGHI, max: 15, reason: solarGHIReason };

            // 4. Critical Habitat (15 pts)
            let solarCritHab = 0, solarCritHabReason = '';
            if(pointInCritHabFinal) { scores.solar.fatal = true; scores.solar.fatalReason = 'Point inside Final Critical Habitat'; solarCritHab = 0; solarCritHabReason = 'FATAL: Inside Final CH'; }
            else if(pointInCritHabProposed) { solarCritHab = 2; solarCritHabReason = 'Inside Proposed CH'; }
            else if(currentData.env.crithabFinal.length > 0 && nearestCritHabDist <= 0.5) { solarCritHab = 5; solarCritHabReason = `Final CH ${nearestCritHabDist.toFixed(1)}mi`; }
            else if(currentData.env.crithabFinal.length > 0 && nearestCritHabDist <= 1) { solarCritHab = 8; solarCritHabReason = `Final CH ${nearestCritHabDist.toFixed(1)}mi`; }
            else if(currentData.env.crithabProposed.length > 0) { solarCritHab = 10; solarCritHabReason = 'Proposed CH nearby'; }
            else if(currentData.env.crithabFinal.length > 0) { solarCritHab = 12; solarCritHabReason = `CH ${nearestCritHabDist.toFixed(1)}mi`; }
            else { solarCritHab = 15; solarCritHabReason = 'None in buffer'; }
            scores.solar.breakdown.criticalHabitat = { points: solarCritHab, max: 15, reason: solarCritHabReason };

            // 5. Flood Zones (12 pts)
            let solarFlood = 0, solarFloodReason = '';
            if(floodZone === 'V' || floodZone === 'VE') { scores.solar.fatal = true; scores.solar.fatalReason = `Point inside ${floodZone} flood zone`; solarFlood = 0; solarFloodReason = `FATAL: Zone ${floodZone}`; }
            else if(['A', 'AE', 'AH', 'AO'].includes(floodZone)) { solarFlood = 3; solarFloodReason = `Zone ${floodZone} - elevated racking needed`; }
            else if(['A99', 'AR'].includes(floodZone)) { solarFlood = 5; solarFloodReason = `Zone ${floodZone}`; }
            else if(floodZone === 'X' || (floodZone && floodZone.includes('X'))) { solarFlood = 8; solarFloodReason = 'Zone X (shaded)'; }
            else if(currentData.env.flood.length > 0) { solarFlood = 10; solarFloodReason = 'Nearby, point outside'; }
            else { solarFlood = 12; solarFloodReason = 'No flood zones'; }
            scores.solar.breakdown.floodZone = { points: solarFlood, max: 12, reason: solarFloodReason };

            // 6. Wetlands (10 pts)
            let solarWet = 0, solarWetReason = '';
            if(pointInWetland) { solarWet = 0; solarWetReason = 'Point inside wetland'; }
            else if(totalWetlandAcres > 5) { solarWet = 2; solarWetReason = `${totalWetlandAcres.toFixed(1)} acres`; }
            else if(totalWetlandAcres > 3) { solarWet = 4; solarWetReason = `${totalWetlandAcres.toFixed(1)} acres`; }
            else if(totalWetlandAcres > 1) { solarWet = 6; solarWetReason = `${totalWetlandAcres.toFixed(1)} acres`; }
            else if(totalWetlandAcres > 0.1) { solarWet = 8; solarWetReason = `${totalWetlandAcres.toFixed(1)} acres`; }
            else { solarWet = 10; solarWetReason = totalWetlandAcres > 0 ? `${totalWetlandAcres.toFixed(2)} acres` : 'None'; }
            scores.solar.breakdown.wetlands = { points: solarWet, max: 10, reason: solarWetReason };

            // 7. Protected Areas (10 pts)
            let solarProt = 0, solarProtReason = '';
            if(pointInProtectedFatal) { scores.solar.fatal = true; scores.solar.fatalReason = 'Point inside Wilderness/NP/Refuge'; solarProt = 0; solarProtReason = 'FATAL: Inside protected'; }
            else if(pointInProtectedOther) { solarProt = 2; solarProtReason = 'Inside other protected'; }
            else if(currentData.env.protected.length > 0 && nearestProtectedDist <= 0.5) { solarProt = 5; solarProtReason = `${nearestProtectedDist.toFixed(1)}mi`; }
            else if(currentData.env.protected.length > 0 && nearestProtectedDist <= 1) { solarProt = 7; solarProtReason = `${nearestProtectedDist.toFixed(1)}mi`; }
            else if(currentData.env.protected.length > 0) { solarProt = 9; solarProtReason = `${nearestProtectedDist.toFixed(1)}mi`; }
            else { solarProt = 10; solarProtReason = 'None in buffer'; }
            scores.solar.breakdown.protectedAreas = { points: solarProt, max: 10, reason: solarProtReason };

            // 8. Land Use (6 pts)
            let solarLand = 0, solarLandReason = currentData.env.landuse;
            if([11, 90, 95].includes(nlcdCode)) { solarLand = 0; }
            else if(nlcdCode === 24) { solarLand = 1; }
            else if([41, 42, 43].includes(nlcdCode)) { solarLand = 2; }
            else if(nlcdCode === 23) { solarLand = 3; }
            else if([21, 22].includes(nlcdCode)) { solarLand = 4; }
            else if([52, 71].includes(nlcdCode)) { solarLand = 5; }
            else if([31, 81, 82].includes(nlcdCode)) { solarLand = 6; }
            else { solarLand = 3; }
            scores.solar.breakdown.landUse = { points: solarLand, max: 6, reason: solarLandReason };

            // 9. Gas Pipelines (3 pts) - less important for solar
            let solarPipe = 0, solarPipeReason = '';
            if(currentData.infra.pipe.length > 0 && nearestPipeDist < 0.5) { solarPipe = 1; solarPipeReason = 'ROW conflict possible'; }
            else if(currentData.infra.pipe.length > 0 && nearestPipeDist <= 1) { solarPipe = 2; solarPipeReason = `${nearestPipeDist.toFixed(1)}mi`; }
            else { solarPipe = 3; solarPipeReason = 'No conflict'; }
            scores.solar.breakdown.gasPipeline = { points: solarPipe, max: 3, reason: solarPipeReason };

            // 10. Infrastructure Density (2 pts)
            let solarDensity = 0, solarDensityReason = '';
            if(transCount > 5) { solarDensity = 2; solarDensityReason = `${transCount} lines`; }
            else if(transCount >= 3) { solarDensity = 1; solarDensityReason = `${transCount} lines`; }
            else { solarDensity = 0; solarDensityReason = `${transCount} lines`; }
            scores.solar.breakdown.infraDensity = { points: solarDensity, max: 2, reason: solarDensityReason };

            // === DATA CENTER SCORING (100 points) ===

            // 1. Transmission (12 pts)
            let dcTrans = 0, dcTransReason = '';
            if(nearestTransDist > 10) { scores.dc.fatal = true; scores.dc.fatalReason = 'No transmission within 10 miles'; dcTrans = 0; dcTransReason = 'FATAL: >10 mi'; }
            else if(nearestTransDist <= 0.5 && maxVoltage >= 345) { dcTrans = 12; dcTransReason = `<0.5mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 1 && maxVoltage >= 345) { dcTrans = 10; dcTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 2 && maxVoltage >= 200) { dcTrans = 8; dcTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 5 && maxVoltage >= 200) { dcTrans = 6; dcTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else if(nearestTransDist <= 5) { dcTrans = 4; dcTransReason = `${nearestTransDist.toFixed(1)}mi, ${maxVoltage}kV`; }
            else { dcTrans = 2; dcTransReason = `${nearestTransDist.toFixed(1)}mi away`; }
            scores.dc.breakdown.transmission = { points: dcTrans, max: 12, reason: dcTransReason };

            // 2. Substations (15 pts)
            let dcSub = 0, dcSubReason = '';
            if(nearestSubDist > 20) { scores.dc.fatal = true; scores.dc.fatalReason = 'No substation within 20 miles'; dcSub = 0; dcSubReason = 'FATAL: >20 mi'; }
            else if(nearestSubDist <= 1) { dcSub = 15; dcSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            else if(nearestSubDist <= 2) { dcSub = 13; dcSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            else if(nearestSubDist <= 5) { dcSub = 10; dcSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            else if(nearestSubDist <= 10) { dcSub = 6; dcSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            else { dcSub = 3; dcSubReason = `${nearestSubDist.toFixed(1)}mi`; }
            scores.dc.breakdown.substation = { points: dcSub, max: 15, reason: dcSubReason };

            // 3. Flood Zones (20 pts) - CRITICAL for DC
            let dcFlood = 0, dcFloodReason = '';
            if(['V', 'VE', 'A', 'AE', 'AH', 'AO', 'AR'].includes(floodZone)) { scores.dc.fatal = true; scores.dc.fatalReason = `Point inside ${floodZone} flood zone`; dcFlood = 0; dcFloodReason = `FATAL: Zone ${floodZone}`; }
            else if(floodZone === 'A99') { dcFlood = 5; dcFloodReason = 'Zone A99'; }
            else if(floodZone === 'X' || (floodZone && floodZone.includes('X'))) { dcFlood = 10; dcFloodReason = 'Zone X (shaded)'; }
            else if(currentData.env.flood.length > 0) { dcFlood = 15; dcFloodReason = 'Nearby, point outside'; }
            else { dcFlood = 20; dcFloodReason = 'No flood zones'; }
            scores.dc.breakdown.floodZone = { points: dcFlood, max: 20, reason: dcFloodReason };

            // 4. Critical Habitat (12 pts)
            let dcCritHab = 0, dcCritHabReason = '';
            if(pointInCritHabFinal) { scores.dc.fatal = true; scores.dc.fatalReason = 'Point inside Final Critical Habitat'; dcCritHab = 0; dcCritHabReason = 'FATAL: Inside Final CH'; }
            else if(pointInCritHabProposed) { dcCritHab = 2; dcCritHabReason = 'Inside Proposed CH'; }
            else if(currentData.env.crithabFinal.length > 0 && nearestCritHabDist <= 0.5) { dcCritHab = 4; dcCritHabReason = `Final CH ${nearestCritHabDist.toFixed(1)}mi`; }
            else if(currentData.env.crithabFinal.length > 0 && nearestCritHabDist <= 1) { dcCritHab = 6; dcCritHabReason = `Final CH ${nearestCritHabDist.toFixed(1)}mi`; }
            else if(currentData.env.crithabProposed.length > 0) { dcCritHab = 8; dcCritHabReason = 'Proposed CH nearby'; }
            else if(currentData.env.crithabFinal.length > 0) { dcCritHab = 10; dcCritHabReason = `CH ${nearestCritHabDist.toFixed(1)}mi`; }
            else { dcCritHab = 12; dcCritHabReason = 'None in buffer'; }
            scores.dc.breakdown.criticalHabitat = { points: dcCritHab, max: 12, reason: dcCritHabReason };

            // 5. Wetlands (10 pts)
            let dcWet = 0, dcWetReason = '';
            if(pointInWetland) { dcWet = 0; dcWetReason = 'Point inside wetland'; }
            else if(totalWetlandAcres > 5) { dcWet = 2; dcWetReason = `${totalWetlandAcres.toFixed(1)} acres`; }
            else if(totalWetlandAcres > 3) { dcWet = 4; dcWetReason = `${totalWetlandAcres.toFixed(1)} acres`; }
            else if(totalWetlandAcres > 1) { dcWet = 6; dcWetReason = `${totalWetlandAcres.toFixed(1)} acres`; }
            else if(totalWetlandAcres > 0.1) { dcWet = 8; dcWetReason = `${totalWetlandAcres.toFixed(1)} acres`; }
            else { dcWet = 10; dcWetReason = totalWetlandAcres > 0 ? `${totalWetlandAcres.toFixed(2)} acres` : 'None'; }
            scores.dc.breakdown.wetlands = { points: dcWet, max: 10, reason: dcWetReason };

            // 6. Protected Areas (10 pts)
            let dcProt = 0, dcProtReason = '';
            if(pointInProtectedFatal) { scores.dc.fatal = true; scores.dc.fatalReason = 'Point inside Wilderness/NP/Refuge'; dcProt = 0; dcProtReason = 'FATAL: Inside protected'; }
            else if(pointInProtectedOther) { dcProt = 2; dcProtReason = 'Inside other protected'; }
            else if(currentData.env.protected.length > 0 && nearestProtectedDist <= 0.5) { dcProt = 5; dcProtReason = `${nearestProtectedDist.toFixed(1)}mi`; }
            else if(currentData.env.protected.length > 0 && nearestProtectedDist <= 1) { dcProt = 7; dcProtReason = `${nearestProtectedDist.toFixed(1)}mi`; }
            else if(currentData.env.protected.length > 0) { dcProt = 9; dcProtReason = `${nearestProtectedDist.toFixed(1)}mi`; }
            else { dcProt = 10; dcProtReason = 'None in buffer'; }
            scores.dc.breakdown.protectedAreas = { points: dcProt, max: 10, reason: dcProtReason };

            // 7. Land Use (8 pts)
            let dcLand = 0, dcLandReason = currentData.env.landuse;
            if([11, 90, 95].includes(nlcdCode)) { dcLand = 0; }
            else if([41, 42, 43].includes(nlcdCode)) { dcLand = 2; }
            else if([81, 82].includes(nlcdCode)) { dcLand = 3; }
            else if([31, 52, 71].includes(nlcdCode)) { dcLand = 4; }
            else if(nlcdCode === 22) { dcLand = 6; }
            else if(nlcdCode === 21) { dcLand = 7; }
            else if([23, 24].includes(nlcdCode)) { dcLand = 8; }
            else { dcLand = 4; }
            scores.dc.breakdown.landUse = { points: dcLand, max: 8, reason: dcLandReason };

            // 8. Gas Pipelines (8 pts) - Important for DC
            let dcPipe = 0, dcPipeReason = '';
            if(currentData.infra.pipe.length === 0 || nearestPipeDist > 5) { dcPipe = 2; dcPipeReason = 'No gas access nearby'; }
            else if(nearestPipeDist <= 1) { dcPipe = 8; dcPipeReason = `${nearestPipeDist.toFixed(1)}mi - gas access`; }
            else if(nearestPipeDist <= 2) { dcPipe = 6; dcPipeReason = `${nearestPipeDist.toFixed(1)}mi`; }
            else { dcPipe = 4; dcPipeReason = `${nearestPipeDist.toFixed(1)}mi`; }
            scores.dc.breakdown.gasPipeline = { points: dcPipe, max: 8, reason: dcPipeReason };

            // 9. Multiple Transmission Feeds (3 pts)
            let dcFeed = 0, dcFeedReason = '';
            if(transCount > 5) { dcFeed = 3; dcFeedReason = `${transCount} lines - excellent redundancy`; }
            else if(transCount >= 4) { dcFeed = 2; dcFeedReason = `${transCount} lines`; }
            else if(transCount >= 2) { dcFeed = 1; dcFeedReason = `${transCount} lines`; }
            else { dcFeed = 0; dcFeedReason = `${transCount} line(s) - limited redundancy`; }
            scores.dc.breakdown.transFeed = { points: dcFeed, max: 3, reason: dcFeedReason };

            // 10. Substation Redundancy (2 pts)
            let dcSubRed = 0, dcSubRedReason = '';
            if(subsWithin10 >= 3) { dcSubRed = 2; dcSubRedReason = `${subsWithin10} subs within 10mi`; }
            else if(subsWithin10 >= 2) { dcSubRed = 1; dcSubRedReason = `${subsWithin10} subs within 10mi`; }
            else { dcSubRed = 0; dcSubRedReason = `${subsWithin10} sub within 10mi`; }
            scores.dc.breakdown.subRedundancy = { points: dcSubRed, max: 2, reason: dcSubRedReason };

            // Calculate totals
            if(scores.solar.fatal) {
                scores.solar.total = 0;
            } else {
                scores.solar.total = Object.values(scores.solar.breakdown).reduce((sum, item) => sum + item.points, 0);
            }
            if(scores.dc.fatal) {
                scores.dc.total = 0;
            } else {
                scores.dc.total = Object.values(scores.dc.breakdown).reduce((sum, item) => sum + item.points, 0);
            }

            return scores;
        }

        function getScoreRating(score, fatal) {
            if(fatal) return { rating: 'FATAL FLAW', colorClass: 'score-fatal' };
            if(score >= 86) return { rating: 'Excellent', colorClass: 'score-excellent' };
            if(score >= 71) return { rating: 'Very Good', colorClass: 'score-good' };
            if(score >= 51) return { rating: 'Good', colorClass: 'score-good' };
            if(score >= 26) return { rating: 'Fair', colorClass: 'score-fair' };
            return { rating: 'Poor', colorClass: 'score-poor' };
        }

        // Keep old function for compatibility but use new one
        function calculateSiteScore() {
            const scores = calculateDetailedScores();
            // Return solar score as primary (can be toggled)
            const { rating, colorClass } = getScoreRating(scores.solar.total, scores.solar.fatal);
            return { score: scores.solar.total, rating, colorClass, detailed: scores };
        }

        // === STATS ===
        function updateStats() {
            const pt = turf.point([lastCoords.lng, lastCoords.lat]);

            // Nearest Substation
            let minD = Infinity, nearestName = "None";
            currentData.infra.subs.forEach(f => {
                if(f.geometry) {
                    const d = turf.distance(pt, f, {units:'miles'});
                    if(d < minD) { minD = d; nearestName = f.properties?.NAME || "Substation"; }
                }
            });
            document.getElementById('stat-sub-dist').innerText = minD < Infinity ? minD.toFixed(2) + " mi" : "--";
            document.getElementById('stat-sub-name').innerText = nearestName;

            // Max Voltage & Distance to highest voltage line
            let maxV = 0, maxVLine = null;
            currentData.infra.trans.forEach(f => {
                const vRaw = f.properties?.VOLTAGE || f.properties?.VOLT_CLASS || "0";
                const nums = String(vRaw).match(/\d+/g);
                if(nums) {
                    const localMax = Math.max(...nums.map(n=>parseInt(n)));
                    if(localMax > maxV && localMax < 999999) { maxV = localMax; maxVLine = f; }
                }
            });
            document.getElementById('stat-max-volt').innerText = maxV > 0 ? maxV + " kV" : "--";
            if(maxVLine && maxVLine.geometry) {
                try {
                    const nearest = turf.nearestPointOnLine(maxVLine, pt, {units: 'miles'});
                    document.getElementById('stat-volt-dist').innerText = nearest.properties.dist.toFixed(2) + " mi away";
                } catch(e) { document.getElementById('stat-volt-dist').innerText = ""; }
            } else {
                document.getElementById('stat-volt-dist').innerText = "";
            }

            // Pipelines
            document.getElementById('stat-pipe-count').innerText = currentData.infra.pipe.length;

            // Land Use
            document.getElementById('stat-landuse').innerText = currentData.env.landuse;

            // Flood Zone Overlap
            let floodOverlap = false, floodZoneAtPoint = "";
            currentData.env.flood.forEach(f => {
                try {
                    if(turf.booleanPointInPolygon(pt, f)) {
                        floodOverlap = true;
                        floodZoneAtPoint = f.properties?.FLD_ZONE || "Yes";
                    }
                } catch(e) {}
            });
            document.getElementById('stat-flood-overlap').innerText = floodOverlap ? "YES" : "No";
            document.getElementById('stat-flood-overlap').style.color = floodOverlap ? "#f59e0b" : "inherit";
            document.getElementById('stat-flood-zone').innerText = floodOverlap ? `Zone ${floodZoneAtPoint}` : `${currentData.env.flood.length} nearby`;

            // Wetlands
            document.getElementById('stat-wet-count').innerText = currentData.env.wetlands.length;

            // Critical Habitat
            const crithabTotal = currentData.env.crithabFinal.length + currentData.env.crithabProposed.length;
            document.getElementById('stat-crithab-count').innerText = crithabTotal;
            const pt2 = turf.point([lastCoords.lng, lastCoords.lat]);
            let inCritHab = false;
            let critHabSpecies = [];
            [...currentData.env.crithabFinal, ...currentData.env.crithabProposed].forEach(f => {
                try {
                    if(f.geometry && f.geometry.type && f.geometry.type.includes('Polygon') && turf.booleanPointInPolygon(pt2, f)) {
                        inCritHab = true;
                        if(f.properties?.comname) critHabSpecies.push(f.properties.comname);
                    }
                } catch(e) {}
            });
            if(inCritHab) {
                document.getElementById('stat-crithab-status').innerText = critHabSpecies.length > 0 ? critHabSpecies[0] : 'POINT INSIDE';
                document.getElementById('stat-crithab-count').style.color = '#dc2626';
            } else {
                document.getElementById('stat-crithab-status').innerText = crithabTotal > 0 ? 'nearby' : '';
                document.getElementById('stat-crithab-count').style.color = 'inherit';
            }

            // Solar Resource
            if(currentData.solar?.ghi) {
                const solarRating = getSolarRating(currentData.solar.ghi);
                document.getElementById('stat-solar-ghi').innerText = currentData.solar.ghi.toFixed(2);
                document.getElementById('stat-solar-ghi').style.color = solarRating.color;
                document.getElementById('stat-solar-rating').innerText = solarRating.rating;
                document.getElementById('stat-solar-rating').style.color = solarRating.color;
            } else {
                document.getElementById('stat-solar-ghi').innerText = '--';
                document.getElementById('stat-solar-rating').innerText = '';
            }

            // Fatal Flaws and Warnings
            const { flaws, warnings } = analyzeFatalFlaws();
            
            const fatalBanner = document.getElementById('fatal-flaw-banner');
            const fatalList = document.getElementById('fatal-flaw-list');
            if(flaws.length > 0) {
                fatalList.innerHTML = flaws.map(f => `<div class="fatal-flaw-item">‚Ä¢ ${f}</div>`).join('');
                fatalBanner.classList.add('active');
            } else {
                fatalBanner.classList.remove('active');
            }

            const warningBanner = document.getElementById('warning-banner');
            const warningList = document.getElementById('warning-list');
            if(warnings.length > 0) {
                warningList.innerHTML = warnings.map(w => `<div class="fatal-flaw-item">‚Ä¢ ${w}</div>`).join('');
                warningBanner.classList.add('active');
            } else {
                warningBanner.classList.remove('active');
            }

            // Site Scores - Calculate detailed scores
            const detailedScores = calculateDetailedScores();
            
            // Solar Score
            const solarRatingInfo = getScoreRating(detailedScores.solar.total, detailedScores.solar.fatal);
            document.getElementById('site-score-value').innerText = detailedScores.solar.total;
            document.getElementById('site-score-value').className = `site-score-value ${solarRatingInfo.colorClass}`;
            document.getElementById('site-score-rating').innerText = `Solar: ${solarRatingInfo.rating}`;
            document.getElementById('site-score-rating').className = `site-score-rating ${solarRatingInfo.colorClass}`;
            
            // DC Score
            const dcRatingInfo = getScoreRating(detailedScores.dc.total, detailedScores.dc.fatal);
            document.getElementById('dc-score-value').innerText = detailedScores.dc.total;
            document.getElementById('dc-score-value').className = `site-score-value ${dcRatingInfo.colorClass}`;
            document.getElementById('dc-score-rating').innerText = `Data Center: ${dcRatingInfo.rating}`;
            document.getElementById('dc-score-rating').className = `site-score-rating ${dcRatingInfo.colorClass}`;

            // Store for export
            currentData.scores = detailedScores;
        }

        // === RENDER LIST ===
        function renderResultsList() {
            const container = document.getElementById('res-content');
            container.innerHTML = "";
            const pt = turf.point([lastCoords.lng, lastCoords.lat]);

            if(currentTab === 'infra') {
                // Show expanded search notice if applicable
                if(currentData.expandedSearchUsed) {
                    container.innerHTML += `<div style="background:#1e3a5f;color:#60a5fa;padding:10px;border-radius:6px;margin-bottom:10px;font-size:11px;">
                        ‚ÑπÔ∏è Search expanded to ${EXPANDED_INFRA_RADIUS} miles to find infrastructure. Features beyond ${radInfra} mi buffer are included for scoring but not shown on map.
                    </div>`;
                }
                
                // Sort by distance and show transmission lines
                currentData.infra.trans.sort((a,b) => (a.properties._distance || 999) - (b.properties._distance || 999)).forEach(f => {
                    const p = f.properties || {};
                    const dist = p._distance !== undefined ? p._distance.toFixed(2) + " mi" : "N/A";
                    const isOutsideBuffer = p._distance > radInfra;
                    container.innerHTML += `<div class="r-item" style="border-left: 3px solid ${isOutsideBuffer ? '#6b7280' : 'cyan'}; ${isOutsideBuffer ? 'opacity:0.7;' : ''}">
                        <div class="r-head">Transmission Line ${isOutsideBuffer ? '<span style="color:#f59e0b;font-size:10px;">(outside buffer)</span>' : ''}</div>
                        <div class="r-row"><span class="r-lbl">Voltage</span><span class="r-val">${p.VOLTAGE || p.VOLT_CLASS || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Distance</span><span class="r-val" style="${isOutsideBuffer ? 'color:#f59e0b;' : ''}">${dist}</span></div>
                        <div class="r-row"><span class="r-lbl">Owner</span><span class="r-val">${p.OWNER || 'N/A'}</span></div>
                    </div>`;
                });
                
                // Sort by distance and show substations
                currentData.infra.subs.sort((a,b) => (a.properties._distance || 999) - (b.properties._distance || 999)).forEach(f => {
                    const p = f.properties || {};
                    const dist = p._distance !== undefined ? p._distance.toFixed(2) : "N/A";
                    const isOutsideBuffer = p._distance > radInfra;
                    container.innerHTML += `<div class="r-item" style="border-left: 3px solid ${isOutsideBuffer ? '#6b7280' : '#f43f5e'}; ${isOutsideBuffer ? 'opacity:0.7;' : ''}">
                        <div class="r-head">${p.NAME || 'Substation'} ${isOutsideBuffer ? '<span style="color:#f59e0b;font-size:10px;">(outside buffer)</span>' : ''}</div>
                        <div class="r-row"><span class="r-lbl">Distance</span><span class="r-val" style="color:${isOutsideBuffer ? '#f59e0b' : '#f43f5e'};font-weight:700">${dist} mi</span></div>
                        <div class="r-row"><span class="r-lbl">Owner</span><span class="r-val">${p.OWNER || 'N/A'}</span></div>
                    </div>`;
                });
                currentData.infra.pipe.forEach(f => {
                    const p = f.properties || {};
                    container.innerHTML += `<div class="r-item" style="border-left: 3px solid #f97316;">
                        <div class="r-head">Gas Pipeline</div>
                        <div class="r-row"><span class="r-lbl">Operator</span><span class="r-val">${p.Operator || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Type</span><span class="r-val">${p.Typepipe || 'N/A'}</span></div>
                    </div>`;
                });
                if(currentData.infra.trans.length === 0 && currentData.infra.subs.length === 0 && currentData.infra.pipe.length === 0) {
                    container.innerHTML = `<div style="color:#f87171;padding:20px">‚ö†Ô∏è No infrastructure found within ${EXPANDED_INFRA_RADIUS} miles. This may indicate a fatal flaw for development.</div>`;
                }
            } else if(currentTab === 'env') {
                currentData.env.flood.forEach(f => {
                    const p = f.properties || {};
                    const inZone = turf.booleanPointInPolygon(pt, f);
                    container.innerHTML += `<div class="r-item" style="border-left: 3px solid #f59e0b;">
                        <div class="r-head">Flood Zone ${p.FLD_ZONE || ''}</div>
                        <div class="r-row"><span class="r-lbl">Risk Level</span><span class="r-val">${getFloodZoneDesc(p.FLD_ZONE)}</span></div>
                        <div class="r-row"><span class="r-lbl">Point Inside?</span><span class="r-val" style="color:${inZone?'#f59e0b':'inherit'}">${inZone ? 'YES' : 'No'}</span></div>
                    </div>`;
                });
                currentData.env.wetlands.forEach(f => {
                    const p = f.properties || {};
                    container.innerHTML += `<div class="r-item" style="border-left: 3px solid #3b82f6;">
                        <div class="r-head">Wetland</div>
                        <div class="r-row"><span class="r-lbl">Type</span><span class="r-val">${p.WETLAND_TYPE || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Acres</span><span class="r-val">${p.ACRES ? parseFloat(p.ACRES).toFixed(1) : ''}</span></div>
                    </div>`;
                });
                if(!container.innerHTML) container.innerHTML = `<div style="color:grey;padding:20px">No environmental features found in ${radEnv} mi buffer.</div>`;
            } else if(currentTab === 'protected') {
                // Protected Areas
                currentData.env.protected.forEach(f => {
                    const p = f.properties || {};
                    let inArea = false;
                    try { if(f.geometry && f.geometry.type && f.geometry.type.includes('Polygon')) inArea = turf.booleanPointInPolygon(pt, f); } catch(e) {}
                    container.innerHTML += `<div class="r-item" style="border-left: 3px solid #8b5cf6;">
                        <div class="r-head">${p.Unit_Nm || 'Protected Area'}</div>
                        <div class="r-row"><span class="r-lbl">Manager</span><span class="r-val">${p.Mang_Name || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Designation</span><span class="r-val">${p.Des_Tp || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Point Inside?</span><span class="r-val" style="color:${inArea?'#8b5cf6':'inherit'}">${inArea ? 'YES' : 'No'}</span></div>
                    </div>`;
                });
                
                // Critical Habitat - Final
                currentData.env.crithabFinal.forEach(f => {
                    const p = f.properties || {};
                    let inArea = false;
                    try { if(f.geometry && f.geometry.type && f.geometry.type.includes('Polygon')) inArea = turf.booleanPointInPolygon(pt, f); } catch(e) {}
                    container.innerHTML += `<div class="r-item" style="border-left: 3px solid #dc2626;">
                        <div class="r-head">Critical Habitat (Final)</div>
                        <div class="r-row"><span class="r-lbl">Species</span><span class="r-val">${p.comname || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Scientific Name</span><span class="r-val">${p.sciname || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Listing Status</span><span class="r-val">${p.listing_st || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Point Inside?</span><span class="r-val" style="color:${inArea?'#dc2626':'inherit'}">${inArea ? 'YES' : 'No'}</span></div>
                    </div>`;
                });
                
                // Critical Habitat - Proposed
                currentData.env.crithabProposed.forEach(f => {
                    const p = f.properties || {};
                    let inArea = false;
                    try { if(f.geometry && f.geometry.type && f.geometry.type.includes('Polygon')) inArea = turf.booleanPointInPolygon(pt, f); } catch(e) {}
                    container.innerHTML += `<div class="r-item" style="border-left: 3px solid #f472b6;">
                        <div class="r-head">Critical Habitat (Proposed)</div>
                        <div class="r-row"><span class="r-lbl">Species</span><span class="r-val">${p.comname || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Scientific Name</span><span class="r-val">${p.sciname || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Listing Status</span><span class="r-val">${p.listing_st || 'N/A'}</span></div>
                        <div class="r-row"><span class="r-lbl">Point Inside?</span><span class="r-val" style="color:${inArea?'#f472b6':'inherit'}">${inArea ? 'YES' : 'No'}</span></div>
                    </div>`;
                });
                
                if(!container.innerHTML) container.innerHTML = `<div style="color:grey;padding:20px">No protected areas or critical habitat found in ${radEnv} mi buffer.</div>`;
            }
        }

        // === EXPORTS ===
        function exportExcelSummary() {
            if(!currentData || !lastCoords) return;
            const wb = XLSX.utils.book_new();
            const pt = turf.point([lastCoords.lng, lastCoords.lat]);
            
            // Check flood overlap
            let floodOverlap = "No", floodZoneAtPoint = "";
            currentData.env.flood.forEach(f => {
                try { if(turf.booleanPointInPolygon(pt, f)) { floodOverlap = "YES"; floodZoneAtPoint = f.properties?.FLD_ZONE || "Unknown"; } } catch(e){}
            });

            // Nearest sub
            let nearestSubName = "None", nearestSubDist = "N/A", nearestSubOwner = "";
            let minD = Infinity;
            currentData.infra.subs.forEach(f => {
                if(f.geometry) {
                    const d = turf.distance(pt, f, {units:'miles'});
                    if(d < minD) { minD = d; nearestSubName = f.properties?.NAME || "Substation"; nearestSubOwner = f.properties?.OWNER || ""; }
                }
            });
            if(minD < Infinity) nearestSubDist = minD.toFixed(2) + " mi";

            // Max voltage line
            let maxV = 0, maxVOwner = "", maxVDist = "N/A";
            currentData.infra.trans.forEach(f => {
                const vRaw = f.properties?.VOLTAGE || f.properties?.VOLT_CLASS || "0";
                const nums = String(vRaw).match(/\d+/g);
                if(nums) {
                    const localMax = Math.max(...nums.map(n=>parseInt(n)));
                    if(localMax > maxV && localMax < 999999) {
                        maxV = localMax;
                        maxVOwner = f.properties?.OWNER || "";
                        try { if(f.geometry) { const n = turf.nearestPointOnLine(f, pt, {units:'miles'}); maxVDist = n.properties.dist.toFixed(2) + " mi"; } } catch(e){}
                    }
                }
            });

            // Critical Habitat overlap check
            let critHabOverlap = "No", critHabSpeciesAtPoint = "";
            [...currentData.env.crithabFinal, ...currentData.env.crithabProposed].forEach(f => {
                try { 
                    if(f.geometry && f.geometry.type && f.geometry.type.includes('Polygon') && turf.booleanPointInPolygon(pt, f)) { 
                        critHabOverlap = "YES"; 
                        critHabSpeciesAtPoint = f.properties?.comname || "Unknown Species"; 
                    } 
                } catch(e){}
            });

            // Get fatal flaws and site score
            const { flaws, warnings } = analyzeFatalFlaws();
            const detailedScores = currentData.scores || calculateDetailedScores();
            const solarRating = getSolarRating(currentData.solar?.ghi);

            const summary = [
                ["SNAPSHOT ANALYSIS REPORT"], [],
                ["Generated:", new Date().toISOString()],
                ["Coordinates:", `${lastCoords.lat.toFixed(6)}, ${lastCoords.lng.toFixed(6)}`],
                ["Infrastructure Buffer:", `${radInfra} mi (${bufferShape})`],
                ["Environmental Buffer:", `${radEnv} mi (${bufferShape})`],
                [], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["SITE FEASIBILITY SCORES"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], [],
                ["SOLAR SCORE:", `${detailedScores.solar.total}/100`],
                ["Solar Rating:", getScoreRating(detailedScores.solar.total, detailedScores.solar.fatal).rating],
                detailedScores.solar.fatal ? ["Solar Fatal Flaw:", detailedScores.solar.fatalReason] : [], [],
                ["DATA CENTER SCORE:", `${detailedScores.dc.total}/100`],
                ["DC Rating:", getScoreRating(detailedScores.dc.total, detailedScores.dc.fatal).rating],
                detailedScores.dc.fatal ? ["DC Fatal Flaw:", detailedScores.dc.fatalReason] : [],
                [], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["SOLAR SCORE BREAKDOWN (100 pts total)"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], [],
            ];
            
            // Add Solar breakdown
            Object.entries(detailedScores.solar.breakdown).forEach(([key, val]) => {
                summary.push([`${key}:`, `${val.points}/${val.max}`, val.reason]);
            });
            
            summary.push([], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["DATA CENTER SCORE BREAKDOWN (100 pts total)"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], []);
            
            // Add DC breakdown
            Object.entries(detailedScores.dc.breakdown).forEach(([key, val]) => {
                summary.push([`${key}:`, `${val.points}/${val.max}`, val.reason]);
            });

            summary.push([], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["FATAL FLAWS DETECTED"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], []);
            
            if(flaws.length > 0) {
                flaws.forEach(f => summary.push(["üö´ " + f]));
            } else {
                summary.push(["None detected"]);
            }
            
            summary.push([], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["SIGNIFICANT CONCERNS"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], []);
            
            if(warnings.length > 0) {
                warnings.forEach(w => summary.push(["‚ö†Ô∏è " + w]));
            } else {
                summary.push(["None detected"]);
            }
            
            summary.push(
                [], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["SITE RISK SUMMARY"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], [],
                ["FLOOD ZONE OVERLAP:", floodOverlap],
                ["Flood Zone at Point:", floodZoneAtPoint || "Not in flood zone"], [],
                ["CRITICAL HABITAT OVERLAP:", critHabOverlap],
                ["Species at Point:", critHabSpeciesAtPoint || "Not in critical habitat"], [],
                ["NEAREST SUBSTATION:", nearestSubName],
                ["  Distance:", nearestSubDist],
                ["  Owner:", nearestSubOwner], [],
                ["HIGHEST VOLTAGE LINE:", maxV > 0 ? maxV + " kV" : "None found"],
                ["  Distance to Line:", maxVDist],
                ["  Owner:", maxVOwner], [],
                ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["SOLAR RESOURCE"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], [],
                ["Global Horizontal Irradiance (GHI):", currentData.solar?.ghi ? `${currentData.solar.ghi.toFixed(2)} kWh/m¬≤/day` : "N/A"],
                ["Direct Normal Irradiance (DNI):", currentData.solar?.dni ? `${currentData.solar.dni.toFixed(2)} kWh/m¬≤/day` : "N/A"],
                ["Tilt at Latitude:", currentData.solar?.tilt ? `${currentData.solar.tilt.toFixed(2)} kWh/m¬≤/day` : "N/A"],
                ["Solar Rating:", solarRating.rating], [],
                ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["ENVIRONMENTAL SUMMARY"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], [],
                ["Dominant Land Use:", currentData.env.landuse],
                ["Total Wetlands:", currentData.env.wetlands.length],
                ["Total Flood Zones:", currentData.env.flood.length],
                ["Total Protected Areas:", currentData.env.protected.length],
                ["Total Critical Habitat (Final):", currentData.env.crithabFinal.length],
                ["Total Critical Habitat (Proposed):", currentData.env.crithabProposed.length], [],
                ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["INFRASTRUCTURE SUMMARY"], ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"], [],
                ["Total Transmission Lines:", currentData.infra.trans.length],
                ["Total Substations:", currentData.infra.subs.length],
                ["Total Pipelines:", currentData.infra.pipe.length]
            );

            // Breakdowns
            const aggregate = (arr, key) => {
                const counts = {};
                arr.forEach(f => { const v = f.properties?.[key] || "Unknown"; counts[v] = (counts[v]||0)+1; });
                return Object.entries(counts).sort((a,b)=>b[1]-a[1]);
            };

            summary.push([], ["Flood Zone Breakdown:"]);
            aggregate(currentData.env.flood, 'FLD_ZONE').forEach(([k,v]) => summary.push([`  ${k} (${getFloodZoneDesc(k)}):`, v]));
            
            summary.push([], ["Wetland Type Breakdown:"]);
            aggregate(currentData.env.wetlands, 'WETLAND_TYPE').forEach(([k,v]) => summary.push([`  ${k}:`, v]));

            summary.push([], ["Pipeline Operators:"]);
            aggregate(currentData.infra.pipe, 'Operator').forEach(([k,v]) => summary.push([`  ${k}:`, v]));

            summary.push([], ["Critical Habitat Species (Final):"]);
            aggregate(currentData.env.crithabFinal, 'comname').forEach(([k,v]) => summary.push([`  ${k}:`, v]));
            
            summary.push([], ["Critical Habitat Species (Proposed):"]);
            aggregate(currentData.env.crithabProposed, 'comname').forEach(([k,v]) => summary.push([`  ${k}:`, v]));

            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(summary), "Summary");

            // Infrastructure sheet
            const infraRows = [["Type", "Name", "Distance (mi)", "Voltage/Details", "Owner"]];
            currentData.infra.subs.forEach(f => {
                const d = f.geometry ? turf.distance(pt, f, {units:'miles'}).toFixed(2) : "";
                infraRows.push(["Substation", f.properties?.NAME || "", d, "", f.properties?.OWNER || ""]);
            });
            currentData.infra.trans.forEach(f => {
                let dist = "";
                try { if(f.geometry) { const n = turf.nearestPointOnLine(f, pt, {units:'miles'}); dist = n.properties.dist.toFixed(2); } } catch(e){}
                infraRows.push(["Transmission", "", dist, f.properties?.VOLTAGE || f.properties?.VOLT_CLASS || "", f.properties?.OWNER || ""]);
            });
            currentData.infra.pipe.forEach(f => {
                infraRows.push(["Pipeline", f.properties?.Pipename || "", "", f.properties?.Typepipe || "", f.properties?.Operator || ""]);
            });
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(infraRows), "Infrastructure");

            // Environmental sheet
            const envRows = [["Type", "Name/Zone", "Details", "Acres"]];
            currentData.env.flood.forEach(f => {
                const inZone = turf.booleanPointInPolygon(pt, f) ? "POINT INSIDE" : "";
                envRows.push(["Flood Zone", f.properties?.FLD_ZONE || "", `${getFloodZoneDesc(f.properties?.FLD_ZONE)} ${inZone}`, ""]);
            });
            currentData.env.wetlands.forEach(f => {
                envRows.push(["Wetland", f.properties?.WETLAND_TYPE || "", f.properties?.ATTRIBUTE || "", f.properties?.ACRES || ""]);
            });
            currentData.env.protected.forEach(f => {
                envRows.push(["Protected", f.properties?.Unit_Nm || "", f.properties?.Mang_Name || "", ""]);
            });
            currentData.env.crithabFinal.forEach(f => {
                const inArea = f.geometry && f.geometry.type && f.geometry.type.includes('Polygon') && turf.booleanPointInPolygon(pt, f) ? "POINT INSIDE" : "";
                envRows.push(["Critical Habitat (Final)", f.properties?.comname || "", `${f.properties?.sciname || ''} - ${f.properties?.listing_st || ''} ${inArea}`, ""]);
            });
            currentData.env.crithabProposed.forEach(f => {
                const inArea = f.geometry && f.geometry.type && f.geometry.type.includes('Polygon') && turf.booleanPointInPolygon(pt, f) ? "POINT INSIDE" : "";
                envRows.push(["Critical Habitat (Proposed)", f.properties?.comname || "", `${f.properties?.sciname || ''} - ${f.properties?.listing_st || ''} ${inArea}`, ""]);
            });
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(envRows), "Environmental");

            // Scoring Methodology sheet
            const methodRows = [
                ["SCORING METHODOLOGY v3.0"], [],
                ["Two separate scores are calculated: Solar Score and Data Center Score"],
                ["Each score is out of 100 points. A FATAL condition = automatic 0."], [],
                ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["SOLAR DEVELOPMENT SCORING (100 points)"], [],
                ["Category", "Max Pts", "Condition", "Points"],
                ["Transmission Lines", "15", "No line within 10mi", "0 (FATAL)"],
                ["", "", "Line 5-10mi any voltage", "3"],
                ["", "", "Line 2-5mi <200kV", "5"],
                ["", "", "Line 2-5mi ‚â•200kV", "7"],
                ["", "", "Line 1-2mi <200kV", "8"],
                ["", "", "Line 1-2mi ‚â•200kV", "10"],
                ["", "", "Line 0.5-1mi ‚â•200kV", "12"],
                ["", "", "Line <0.5mi ‚â•345kV", "15"], [],
                ["Substations", "12", "No substation within 20mi", "0 (FATAL)"],
                ["", "", "Substation 10-20mi", "3"],
                ["", "", "Substation 5-10mi", "6"],
                ["", "", "Substation 2-5mi", "9"],
                ["", "", "Substation <2mi", "12"], [],
                ["Solar Irradiance (GHI)", "15", "GHI <3.5 kWh/m¬≤/day", "0"],
                ["", "", "GHI 3.5-4.0", "3"],
                ["", "", "GHI 4.0-4.5", "6"],
                ["", "", "GHI 4.5-5.0", "9"],
                ["", "", "GHI 5.0-5.5", "12"],
                ["", "", "GHI ‚â•5.5", "15"], [],
                ["Critical Habitat", "15", "Point inside Final CH", "0 (FATAL)"],
                ["", "", "Point inside Proposed CH", "2"],
                ["", "", "Final CH within 0.5mi", "5"],
                ["", "", "Final CH within 1mi", "8"],
                ["", "", "Proposed CH only nearby", "10"],
                ["", "", "Any CH 1-3mi", "12"],
                ["", "", "No CH in buffer", "15"], [],
                ["Flood Zones", "12", "Point inside Zone V/VE", "0 (FATAL)"],
                ["", "", "Point inside Zone A/AE/AH/AO", "3"],
                ["", "", "Point inside Zone A99/AR", "5"],
                ["", "", "Point inside Zone X (shaded)", "8"],
                ["", "", "Flood zones nearby, point outside", "10"],
                ["", "", "No flood zones", "12"], [],
                ["Wetlands", "10", "Point inside wetland", "0"],
                ["", "", ">5 acres in buffer", "2"],
                ["", "", "3-5 acres", "4"],
                ["", "", "1-3 acres", "6"],
                ["", "", "0.1-1 acre", "8"],
                ["", "", "<0.1 acre or none", "10"], [],
                ["Protected Areas", "10", "Point inside Wilderness/NP/Refuge", "0 (FATAL)"],
                ["", "", "Point inside other protected", "2"],
                ["", "", "Protected within 0.5mi", "5"],
                ["", "", "Protected within 1mi", "7"],
                ["", "", "Protected >1mi", "9"],
                ["", "", "None in buffer", "10"], [],
                ["Land Use", "6", "Water/Wetlands (NLCD 11,90,95)", "0"],
                ["", "", "Developed High (24)", "1"],
                ["", "", "Forest (41,42,43)", "2"],
                ["", "", "Developed Medium (23)", "3"],
                ["", "", "Developed Low/Open (21,22)", "4"],
                ["", "", "Shrub/Grassland (52,71)", "5"],
                ["", "", "Barren/Pasture/Crops (31,81,82)", "6"], [],
                ["Gas Pipelines", "3", "ROW conflict (<0.5mi)", "1"],
                ["", "", "Pipeline within 1mi", "2"],
                ["", "", "No conflict", "3"], [],
                ["Infra Density", "2", "<3 transmission lines", "0"],
                ["", "", "3-5 lines", "1"],
                ["", "", ">5 lines", "2"], [],
                ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["DATA CENTER SCORING (100 points)"], [],
                ["Category", "Max Pts", "Condition", "Points"],
                ["Transmission Lines", "12", "No line within 10mi", "0 (FATAL)"],
                ["", "", "Line 5-10mi", "2"],
                ["", "", "Line 2-5mi <200kV", "4"],
                ["", "", "Line 2-5mi ‚â•200kV", "6"],
                ["", "", "Line 1-2mi ‚â•200kV", "8"],
                ["", "", "Line 0.5-1mi ‚â•345kV", "10"],
                ["", "", "Line <0.5mi ‚â•345kV", "12"], [],
                ["Substations", "15", "No substation within 20mi", "0 (FATAL)"],
                ["", "", "Substation 10-20mi", "3"],
                ["", "", "Substation 5-10mi", "6"],
                ["", "", "Substation 2-5mi", "10"],
                ["", "", "Substation 1-2mi", "13"],
                ["", "", "Substation <1mi", "15"], [],
                ["Flood Zones", "20", "Point inside Zone V/VE/A/AE/AH/AO/AR", "0 (FATAL)"],
                ["", "", "Point inside Zone A99", "5"],
                ["", "", "Point inside Zone X (shaded)", "10"],
                ["", "", "Flood zones nearby, point outside", "15"],
                ["", "", "No flood zones", "20"], [],
                ["Critical Habitat", "12", "Point inside Final CH", "0 (FATAL)"],
                ["", "", "Point inside Proposed CH", "2"],
                ["", "", "Final CH within 0.5mi", "4"],
                ["", "", "Final CH within 1mi", "6"],
                ["", "", "Proposed CH only nearby", "8"],
                ["", "", "Any CH 1-3mi", "10"],
                ["", "", "No CH in buffer", "12"], [],
                ["Wetlands", "10", "Same as Solar scoring", ""],
                ["Protected Areas", "10", "Same as Solar scoring", ""], [],
                ["Land Use", "8", "Water/Wetlands", "0"],
                ["", "", "Forest", "2"],
                ["", "", "Crops/Pasture", "3"],
                ["", "", "Barren/Shrub/Grassland", "4"],
                ["", "", "Developed Low", "6"],
                ["", "", "Developed Open Space", "7"],
                ["", "", "Developed Med/High", "8"], [],
                ["Gas Pipelines", "8", "No pipeline within 5mi", "2"],
                ["", "", "Pipeline 2-5mi", "4"],
                ["", "", "Pipeline 1-2mi", "6"],
                ["", "", "Pipeline <1mi (gas access)", "8"], [],
                ["Trans Redundancy", "3", "<2 lines", "0"],
                ["", "", "2-3 lines", "1"],
                ["", "", "4-5 lines", "2"],
                ["", "", ">5 lines", "3"], [],
                ["Sub Redundancy", "2", "1 substation within 10mi", "0"],
                ["", "", "2 substations", "1"],
                ["", "", "3+ substations", "2"], [],
                ["‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"],
                ["SCORE INTERPRETATION"], [],
                ["Score Range", "Rating", "Interpretation"],
                ["0", "FATAL FLAW", "Disqualifying conditions present"],
                ["1-25", "Poor", "Significant challenges, likely not viable"],
                ["26-50", "Fair", "Multiple concerns, detailed study needed"],
                ["51-70", "Good", "Some challenges but generally viable"],
                ["71-85", "Very Good", "Minor concerns, strong candidate"],
                ["86-100", "Excellent", "Ideal site, minimal constraints"],
            ];
            XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(methodRows), "Scoring Methodology");

            XLSX.writeFile(wb, `Snapshot_${lastCoords.lat.toFixed(4)}_${lastCoords.lng.toFixed(4)}.xlsx`);
            showToast("Excel Report Exported");
        }

        function exportGeoJSON() {
            if(!currentData) return;
            const features = [
                ...currentData.infra.trans, ...currentData.infra.subs, ...currentData.infra.pipe,
                ...currentData.env.wetlands, ...currentData.env.flood, ...currentData.env.protected,
                ...currentData.env.crithabFinal, ...currentData.env.crithabProposed
            ];
            const blob = new Blob([JSON.stringify({type:"FeatureCollection", features}, null, 2)], {type:'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = "Snapshot_Data.geojson"; a.click();
            URL.revokeObjectURL(url);
            showToast("GeoJSON Exported");
        }

        function exportCSV(type) {
            if(!currentData) return;
            let rows = [];
            if(type === 'env') {
                rows.push(["Layer","Type","Name","Details","Acres"]);
                currentData.env.flood.forEach(f => rows.push(["Flood", f.properties?.FLD_ZONE, "", getFloodZoneDesc(f.properties?.FLD_ZONE), ""]));
                currentData.env.wetlands.forEach(f => rows.push(["Wetland", f.properties?.WETLAND_TYPE, "", f.properties?.ATTRIBUTE, f.properties?.ACRES]));
                currentData.env.protected.forEach(f => rows.push(["Protected", "", f.properties?.Unit_Nm, f.properties?.Mang_Name, ""]));
                currentData.env.crithabFinal.forEach(f => rows.push(["Critical Habitat (Final)", f.properties?.listing_st, f.properties?.comname, f.properties?.sciname, ""]));
                currentData.env.crithabProposed.forEach(f => rows.push(["Critical Habitat (Proposed)", f.properties?.listing_st, f.properties?.comname, f.properties?.sciname, ""]));
            } else {
                const pt = turf.point([lastCoords.lng, lastCoords.lat]);
                rows.push(["Layer","Name","Voltage","Distance_mi","Owner"]);
                currentData.infra.subs.forEach(f => {
                    const d = f.geometry ? turf.distance(pt, f, {units:'miles'}).toFixed(2) : "";
                    rows.push(["Substation", f.properties?.NAME, "", d, f.properties?.OWNER]);
                });
                currentData.infra.trans.forEach(f => {
                    let dist = "";
                    try { if(f.geometry) { const n = turf.nearestPointOnLine(f, pt, {units:'miles'}); dist = n.properties.dist.toFixed(2); } } catch(e){}
                    rows.push(["Transmission", "", f.properties?.VOLTAGE || f.properties?.VOLT_CLASS, dist, f.properties?.OWNER]);
                });
                currentData.infra.pipe.forEach(f => rows.push(["Pipeline", f.properties?.Pipename, "", "", f.properties?.Operator]));
            }
            const csv = rows.map(r => r.map(c => `"${(c||'').toString().replace(/"/g,'""')}"`).join(",")).join("\n");
            const blob = new Blob([csv], {type:'text/csv'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `Snapshot_${type}.csv`; a.click();
            URL.revokeObjectURL(url);
            showToast(`${type === 'env' ? 'Environmental' : 'Infrastructure'} CSV Exported`);
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg; t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2500);
        }
    </script>
</body>
</html>

